<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面试相关题目]]></title>
    <url>%2F2018%2F11%2F17%2F%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[1.KVO实现原理KVO基本原理 1.KVO是基于runtime机制实现的 2.当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的通知机制 3.如果原类为Person，那么生成的派生类名为NSKVONotifying_Person 4.每个类对象中都有一个isa指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法 5.键值观察通知依赖于NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey:一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey:会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。 KVO深入原理： 1.Apple 使用了 isa 混写（isa-swizzling）来实现 KVO 。当观察对象A时，KVO机制动态创建一个新的名为： NSKVONotifying_A的新类，该类继承自对象A的本类，且KVO为NSKVONotifying_A重写观察属性的setter 方法，setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象属性值的更改情况。 2.NSKVONotifying_A类剖析：在这个过程，被观察对象的 isa 指针从指向原来的A类，被KVO机制修改为指向系统新创建的子类 NSKVONotifying_A类，来实现当前类属性值改变的监听； 3.所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对KVO的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为“NSKVONotifying_A”的类()，就会发现系统运行到注册KVO的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为NSKVONotifying_A的中间类，并指向这个中间类了。 4.（isa 指针的作用：每个对象都有isa 指针，指向该对象的类，它告诉 Runtime 系统这个对象的类是什么。所以对象注册为观察者时，isa指针指向新子类，那么这个被观察的对象就神奇地变成新子类的对象（或实例）了。） 因而在该对象上对 setter 的调用就会调用已重写的 setter，从而激活键值通知机制 5.子类setter方法剖析：KVO的键值观察通知依赖于 NSObject 的两个方法:willChangeValueForKey:和 didChangevlueForKey:，在存取数值的前后分别调用2个方法： 被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该 keyPath 的属性值即将变更；当改变发生后， didChangeValueForKey: 被调用，通知系统该 keyPath 的属性值已经变更；之后， observeValueForKey:ofObject:change:context: 也会被调用。且重写观察属性的setter 方法这种继承方式的注入是在运行时而不是编译时实现的。 weak实现原理Runtime维护了一个weak表，用于存储指向某个对象的所有weak指针。weak表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象的地址）数组。 1、初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。 2、添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。 3、释放时，调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。 追问的问题一：1.实现weak后，为什么对象释放后会自动为nil？ runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为 0 的时候会 dealloc，假如 weak 指向的对象内存地址是 a ，那么就会以 a 为键， 在这个 weak 表中搜索，找到所有以 a 为键的 weak 对象，从而设置为 nil 。 追问的问题二：2.当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？ 1、调用objc_release 2、因为对象的引用计数为0，所以执行dealloc 3、在dealloc中，调用了_objc_rootDealloc函数 4、在_objc_rootDealloc中，调用了object_dispose函数 5、调用objc_destructInstance 6、最后调用objc_clear_deallocating,详细过程如下： 1234a. 从weak表中获取废弃对象的地址为键值的记录b. 将包含在记录中的所有附有 weak修饰符变量的地址，赋值为 nilc. 将weak表中该记录删除d. 从引用计数表中删除废弃对象的地址为键值的记录 Controller臃肿优化1、添加分类。2、抽象功能类，页面及功能抽出。3、MVVM，部分逻辑放在ViewModel中。4、继承，部分公共功能放在基类中。 UBTSDK 整体上主要包含 4 个部分：AOP、Event Collector、Event Cache、Event Upload。 SDK 中的这 4 个模块各自的主要功能如下： AOP：提供数据收集所需要的时机，即通过 Method Swizzling 来 hook 相应类的方法，然后以 Post Notification 的方式提供出去。 Event Collector：监听通知，针对当前事件执行相应的数据收集，并将收集的事件数据提交给缓存模块。 Event Cache：负责事件数据的缓存、序列化以及读取操作，其中包括内存缓存与磁盘缓存。 Event Upload：基于一定的上报策略执行对已收集的事件数据的上报。 id和NSObject＊的区别id是一个 objc_object 结构体指针，定义是 typedef struct objc_object *id id可以理解为指向对象的指针。所有oc的对象 id都可以指向，编译器不会做类型检查，id调用任何存在的方法都不会在编译阶段报错，当然如果这个id指向的对象没有这个方法，该崩溃还是会崩溃的。 NSObject *指向的必须是NSObject的子类，调用的也只能是NSObject里面的方法否则就要做强制类型转换。 不是所有的OC对象都是NSObject的子类，还有一些继承自NSProxy。NSObject *可指向的类型是id的子集。 堆和栈的区别管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。 申请大小： 栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出 分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。 分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的。 高效的实现控件的圆角效果1、直接系统方法，cornerRadius 和 maskToBounds，这种方法比较简单，代码量较少，但是操作layer肯定会影响性能，会造成离屏渲染。离屏渲染是指：1离屏渲染，指的是 GPU 或 CPU 在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。过程中需要切换 contexts (上下文环境),先从当前屏幕切换到离屏的contexts，渲染结束后，又要将 contexts 切换回来，而切换过程十分耗费性能。 2、设计切一张圆角且阴影的图片，使用1resizableImage(withCapInsets: UIEdgeInsets(top: 10, left: 10, bottom: 10, right: 10), resizingMode: .stretch) 四周不拉伸，拉伸内容3、使用CAShapeLayer和UIBezierPath来设置圆角，消耗内存较小，渲染较快，缺点：操作了layer，对性能有影响，有离屏渲染。12345678910- (void)setLayerAndBezierPathCutCircularWithView:(UIView *) view&#123; // 创建BezierPath 并设置角 和 半径 这里只设置了 左上 和 右上 UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:view.bounds byRoundingCorners:UIRectCornerTopLeft | UIRectCornerTopRight cornerRadii:CGSizeMake(10, 10)]; CAShapeLayer *layer = [[CAShapeLayer alloc] init]; layer.frame = view.bounds; layer.path = path.CGPath; view.layer.mask = layer;&#125; 4、使用Core Graphics框架 和 UIBezierPath 画出一个圆角 123456789- (void)setGraphicsCutCirculayWithView:(UIImageView *) view&#123; UIGraphicsBeginImageContextWithOptions(view.bounds.size, NO, 1.0); [[UIBezierPath bezierPathWithRoundedRect:view.bounds cornerRadius:5] addClip]; [view drawRect:view.bounds]; view.image = UIGraphicsGetImageFromCurrentImageContext(); // 结束 UIGraphicsEndImageContext();&#125; copy//单层结论并不准确。 浅复制，单层深复制，完全复制(每一层都深复制) 。 浅复制也就是所说的指针复制，并没有进行对象复制; 单层深复制，也就是我们经常说的深复制，我这里说的单层深复制是对于集合类所说的(即NSArray,NSDictionary,NSSet)，单层深复制指的是只复制了该集合类的最外层，里边的元素没有复制，(即这两个集合类的地址不一样，但是两个集合里所存储的元素的地址是一样的); 完全复制，指的是完全复制整个集合类，也就是说两个集合地址不一样，里边所存储的元素地址也不一样; 非集合类（NSString，NSNumber）1234[immutableObject copy] //浅复制 [immutableObject mutableCopy] //深复制[mutableObject copy] //深复制[mutableObject mutableCopy] //深复制 结论：不可变进行copy是浅复制，mutableCopy是深复制，可变的copy，mutableCopy都是深复制。 集合类（NSArray，NSDictionary, NSSet)1234[immutableObject copy] //浅复制[immutableObject mutableCopy] //单层深复制[mutableObject copy] //单层深复制[mutableObject mutableCopy] //单层深复制 结论：不可变进行copy是浅复制，mutableCopy是单层深复制，可变的copy，mutableCopy都是单层深复制。1NSArray *copyArray = [[NSArray alloc] initWithArray:array copyItems:YES]; // 完全复制 以上我们所说的两种情况默认都实现了NSCopying和NSMutableCopying协议对于自定义继承自NSObject的类 copy需要实现NSCopying协议，然后实现以下方法，否则copy会crash 需要特别注意，可变数组或字典的copy与mutableCopy的区别，https://blog.csdn.net/Mazy_ma/article/details/51899397 Struct与ClassSwift 中类和结构体非常类似，都具有定义和使用属性、方法、下标和构造器等面向对象特性，但是结构体不具有继承性，也不具备运行时强制类型转换、使用析构器和使用引用计等能力。 Swift 中 struct 是值类型，而 class 是引用类型，所以这篇文章 struct 的行为也可以用到所有的值类型上面，相同地 class 的行为也可以用到引用类型上。 优点： 1、安全性： 因为 Struct 是用值类型传递的，它们没有引用计数。 2、内存： 由于他们没有引用数，他们不会因为循环引用导致内存泄漏。 3、速度: 值类型通常来说是以栈的形式分配的，而不是用堆。因此他们比 Class 要快很多! (http://stackoverflow.com/a/24243626/596821) 4、拷贝： Objective-C 里拷贝一个对象,你必须选用正确的拷贝类型（深拷贝、浅拷贝）,而值类型的拷贝则非常轻松！ 5、线程安全 值类型是自动线程安全的。无论你从哪个线程去访问你的 Struct ，都非常简单。 缺点： 1、Objective-C 当你的项目的代码是 Swift 和 Objective-C 混合开发时，你会发现在 Objective-C 的代码里无法调用 Swift 的 Struct。因为要在 Objective-C 里调用 Swift 代码的话，对象需要继承于 NSObject。 Struct 不是 Objective-C 的好朋友。 2、继承 Struct 不能相互继承。 3、NSUserDefaults Struct 不能被序列化成 NSData 对象。 知识延伸：为什么访问struct比class快？“堆”和“栈”并不是数据结构上的Heap跟Stack，而是程序运行中的不同内存空间。栈是程序启动的时候，系统事先分配的，使用过程中，系统不干预；堆是用的时候才向系统申请的，用完了需要交还，这个申请和交还的过程开销相对就比较大了。 栈是编译时分配空间，而堆是动态分配（运行时分配空间），所以栈的速度快。 从两方面来考虑： 1231.分配和释放：堆在分配和释放时都要调用函数（MALLOC,FREE)，比如分配时会到堆空间去寻找足够大小的空间（因为多次分配释放后会造成空洞），这些都会花费一定的时间，而栈却不需要这些。2.访问时间：访问堆的一个具体单元，需要两次访问内存，第一次得取得指针，第二次才是真正得数据，而栈只需访问一次。 响应链及RunLoop继承关系将UIResponder作为父类派生出如下子类 123456789-UIResponder -UIApplication -UIView -UIControl -UIViewController 1.我们可以看到所有的UIView都继承自UIResponder，这也很容易理解，因为一般的UIView都将在界面上呈现，对于触摸事件都会非常敏感。 2.而UIControl类则是UIButton等控件的父类，系统帮助我们将此类控件的共有操作都封装在UIControl中。 3.对于UIApplication和UIViewController不像UIView那样可被触摸，但是不要忘记了UIResponder除了可以处理触摸事件外还可以进行其他事件的处理，而这些事件会被响应者链机制传递到 UIApplication和UIViewController。 UIResponder 是 UIView 的父类。responder 能够处理触摸、手势、远程控制等事件。之所以它是一个单独的类而没有合并到 UIView 中，是因为 UIResponder 有更多的子类，最明显的就是 UIApplication 和 UIViewController。 UIView 子类处理所有跟内容绘制有关的事情以及触摸时间。UIControl 建立在视图上，增加了更多的交互支持。最重要的是，它增加了 target / action 模式。UIView通过delegate交互。 响应链大概有以下几个步骤： 设备将touch到的UITouch和UIEvent对象打包, 放到当前活动的Application的事件队列中 单例的UIApplication会从事件队列中取出触摸事件并传递给单例UIWindow UIWindow使用hitTest:withEvent:方法查找touch操作的所在的视图view RunLoop 的作用1.保证程序不退出保活线程，它就是一个死循环：”接受事件 -&gt; …等待 -&gt; 处理” 2.负责监听管理事件，触摸事件（用户交互事件）、时钟事件（Timer）、网络事件（网络请求回调接收等）以及系统事件内核事件； 3.如果没有事件则进入睡眠状态 CFRunLoopMode的类型 kCFRunLoopDefaultModeApp的默认Mode，通常主线程是在这个Mode下运行 UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响 UIInitializationRunLoopMode:在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用 GSEventReceiveRunLoopMode:接受系统事件的内部 Mode，通常用不到 kCFRunLoopCommonModes:这是一个占位用的Mode，作为标记kCFRunLoopDefaultMode和UITrackingRunLoopMode用，并不是一种真正的Mode 1234567891011RunLoop这边我大概讲一下： 主线程的RunLoop被唤醒 通知Observer，处理Timer和Source 0 Springboard接受touch event之后转给App进程 RunLoop处理Source 1，Source1 就会触发回调，并调用_UIApplicationHandleEventQueue() 进行应用内部的分发。 RunLoop处理完毕进入睡眠，此前会释放旧的autorelease pool并新建一个autorelease pool .NStimer准吗？谈谈你的看法？如果不准该怎样实现一个精确的NSTimer?1.不准 2.不准的原因如下： 1、NSTimer加在main runloop中，模式是NSDefaultRunLoopMode，main负责所有主线程事件，例如UI界面的操作，复杂的运算，这样在同一个runloop中timer就会产生阻塞。 2、模式的改变。主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。 当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个ScrollView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。所以就会影响到NSTimer不准的情况。 PS:DefaultMode 是 App 平时所处的状态，rackingRunLoopMode 是追踪 ScrollView 滑动时的状态。 方法一1、在主线程中进行NSTimer操作，但是将NSTimer实例加到main runloop的特定mode（模式）中。避免被复杂运算操作或者UI界面刷新所干扰。123self.timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(showTime) userInfo:nil repeats:YES];[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes]; 2、在子线程中进行NSTimer的操作，再在主线程中修改UI界面显示操作结果；1234567891011121314151617181920212223242526272829- (void)timerMethod2 &#123;NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];[thread start];&#125;- (void)newThread&#123;@autoreleasepool&#123;[NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(showTime) userInfo:nil repeats:YES];[[NSRunLoop currentRunLoop] run];&#125;&#125;总结：一开始的时候系统就为我们将主线程的main runloop隐式的启动了。在创建线程的时候，可以主动获取当前线程的runloop。每个子线程对应一个runloop 方法二：直接使用GCD替代！GCD创建的定时器不受RunLoop中Modes影响1234567891011121314151617181920// 定义需要计时的时间var timeCount = 60// 在global线程里创建一个时间源let codeTimer = DispatchSource.makeTimerSource(queue: DispatchQueue.global())// 设定这个时间源是每秒循环一次，立即开始codeTimer.schedule(deadline: .now(), repeating: .seconds(1))// 设定时间源的触发事件codeTimer.setEventHandler(handler: &#123; // 每秒计时一次 timeCount = timeCount - 1 // 时间到了取消时间源 if timeCount &lt;= 0 &#123; codeTimer.cancel() &#125; // 返回主线程处理一些事件，更新UI等等 DispatchQueue.main.async &#123; &#125;&#125;)// 启动时间源codeTimer.resume() 内存分区1).代码区：存放函数二进制代码 2).数据区：系统运行时申请内存并初始化，系统退出时由系统释放。存放全局变量、静态变量、常量 3).堆区：通过malloc等函数或new等操作符动态申请得到，需程序员手动申请和释放 4).栈区：函数模块内申请，函数结束时由系统自动释放。存放局部变量、函数参数 block和函数指针的理解相似点： 函数指针和Block都可以实现回调的操作，声明上也很相似，实现上都可以看成是一个代码片段。 函数指针类型和Block类型都可以作为变量和函数参数的类型。（typedef定义别名之后，这个别名就是一个类型） 不同点： 函数指针只能指向预先定义好的函数代码块（可以是其他文件里面定义，通过函数参数动态传入的），函数地址是在编译链接时就已经确定好的。 Block本质是Objective-C对象，是NSObject的子类，可以接收消息。 函数里面只能访问全局变量，而Block代码块不光能访问全局变量，还拥有当前栈内存和堆内存变量的可读性（当然通过__block访问指示符修饰的局部变量还可以在block代码块里面进行修改）。 从内存的角度看，函数指针只不过是指向代码区的一段可执行代码，而block实际上是程序运行过程中在栈内存动态创建的对象，可以向其发送copy消息将block对象拷贝到堆内存，以延长其生命周期。 对象内存结构中的 isa 指针是用来做什么的？问题:Objective-C 对象内存结构中的 isa 指针是用来做什么的，有什么用？答案:Objective-C 是一门面向对象的编程语言。每一个对象都是一个类的实例。在 Objective-C 语言的内部，每一个对象都有一个名为 isa 的指针，指向该对象的类。每一个类描述了一系列它的实例的特点，包括成员变量的列表，成员函数的列表等。每一个对象都可以接受消息，而对象能够接收的消息列表是保存在它所对应的类中。 在 Xcode 中按Shift + Command + O, 然后输入 NSObject.h 和 objc.h，可以打开 NSObject 的定义头文件，通过头文件我们可以看到，NSObject 就是一个包含 isa 指针的结构体，如下图所示： 按照面向对象语言的设计原则，所有事物都应该是对象（严格来说 Objective-C 并没有完全做到这一点，因为它有象 int, double 这样的简单变量类型，而 Swift 语言，连 int 变量也是对象）。在 Objective-C 语言中，每一个类实际上也是一个对象。每一个类也有一个名为 isa 的指针。每一个类也可以接受消息，例如代码[NSObject alloc]，就是向 NSObject 这个类发送名为alloc消息。 在 Xcode 中按Shift + Command + O, 然后输入 runtime.h，可以打开 Class 的定义头文件，通过头文件我们可以看到，Class 也是一个包含 isa 指针的结构体，如下图所示。（图中除了 isa 外还有其它成员变量，但那是为了兼容非 2.0 版的 Objective-C 的遗留逻辑，大家可以忽略它。） 因为类也是一个对象，那它也必须是另一个类的实列，这个类就是元类 (metaclass)。元类保存了类方法的列表。当一个类方法被调用时，元类会首先查找它本身是否有该类方法的实现，如果没有，则该元类会向它的父类查找该方法，直到一直找到继承链的头。 元类 (metaclass) 也是一个对象，那么元类的 isa 指针又指向哪里呢？为了设计上的完整，所有的元类的 isa 指针都会指向一个根元类 (root metaclass)。根元类 (root metaclass) 本身的 isa 指针指向自己，这样就行成了一个闭环。上面提到，一个对象能够接收的消息列表是保存在它所对应的类中的。在实际编程中，我们几乎不会遇到向元类发消息的情况，那它的 isa 指针在实际上很少用到。不过这么设计保证了面向对象概念在 Objective-C 语言中的完整，即语言中的所有事物都是对象，都有 isa 指针。 我们再来看看继承关系，由于类方法的定义是保存在元类 (metaclass) 中，而方法调用的规则是，如果该类没有一个方法的实现，则向它的父类继续查找。所以，为了保证父类的类方法可以在子类中可以被调用，所以子类的元类会继承父类的元类，换而言之，类对象和元类对象有着同样的继承关系。 我很想把关系说清楚一些，但是这块儿确实有点绕，我们还是来看图吧，很多时候图象比文字表达起来更为直观。下面这张图或许能够让大家对 isa 和继承的关系清楚一些： 我们可以从图中看出： NSObject 的类中定义了实例方法，例如 -(id)init 方法 和 - (void)dealloc 方法。NSObject 的元类中定义了类方法，例如 +(id)alloc 方法 和 + (void)load 、+ (void)initialize 方法。NSObject 的元类继承自 NSObject 类，所以 NSObject 类是所有类的根，因此 NSObject 中定义的实例方法可以被所有对象调用，例如 - (id)init 方法 和 - (void)dealloc 方法。NSObject 的元类的 isa 指向自己。isa swizzling 的应用 系统提供的 KVO 的实现，就利用了动态地修改 isa 指针的值的技术。在 苹果的文档中可以看到如下描述 12345Key-Value Observing Implementation DetailsAutomatic key-value observing is implemented using a technique called isa-swizzling.The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance. iOS Runtime详解https://www.jianshu.com/p/6ebda3cd8052 NSCacheSD图片缓存就用的该类 一个可变集合，用于临时存储临时键值对，在资源不足的情况下被释放。NSCache类包含了各种自动释放内存的机制，可以确保缓存不会占用太多的系统内存。如果其他应用程序需要内存，这些机制会从缓存中删除一些项目，从而最大限度地减少其内存占用。您可以从不同的线程中添加，删除和查询缓存中的项目，而无需自己锁定缓存。与NSMutableDictionary对象不同，缓存不会复制放入其中的关键对象。您通常使用NSCache对象临时存储对象与创建重要的临时数据。重用这些对象可以提供性能优势，因为它们的值不必重新计算。但是，这些对象对应用程序并不重要，如果内存不足，可以将其释放。如果释放，则需要时重新计算它们的值。具有可以在不使用时释放的子组件的对象可以采用NSDiscardableContent协议来改善缓存机制的行为。默认情况下，如果缓存中的NSDiscardableContent对象的内容被释放，它们将被自动删除，尽管这个自动删除机制是可以改变的。如果一个NSDiscardableContent对象被放入缓存中，缓存在移除时调用discardContentIfPossible。 如果项目开始容错处理没做？如何防止拦截潜在的崩溃？例： 1、category给类添加方法用来替换掉原本存在潜在崩溃的方法。 2、利用runtime方法交换技术，将系统方法替换成类添加的新方法。 3、利用异常的捕获来防止程序的崩溃，并且进行相应的处理。 总结： 1、不要过分相信服务器返回的数据会永远的正确。 2、在对数据处理上，要进行容错处理，进行相应判断之后再处理数据，这是一个良好的编程习惯。 iOS中block和delegate的区别1.从源头上理解和区别block和delegate delegate运行成本低，block的运行成本高。 block出栈需要将使用的数据从栈内存拷贝到堆内存，当然对象的话就是加计数，使用完或者block置nil后才消除。delegate只是保存了一个对象指针，直接回调，没有额外消耗。就像C的函数指针，只多做了一个查表动作。 2.从使用场景区别block和delegate 有多个相关方法。假如每个方法都设置一个 block, 这样会更麻烦。而 delegate 让多个方法分成一组，只需要设置一次，就可以多次回调。当多于 3 个方法时就应该优先采用 delegate。当1，2个回调时，则使用block。 delegate更安全些，比如: 避免循环引用。使用 block 时稍微不注意就形成循环引用，导致对象释放不了。这种循环引用，一旦出现就比较难检查出来。而 delegate 的方法是分离开的，并不会引用上下文，因此会更安全些。 内存泄漏的几种情况答：循环引用：delegate，block，timer等 图片没释放，instrument调试后，发现没被释放的全是imageIO，差不多就知道了，把读图的方式，从[UIImage imageNamed:@””],改成imageWithContentsOfFile，就可以了。 CoreFoundation对象(C对象) : 只要函数中包含了create\new\copy\retain等关键字, 那么这些方法产生的对象, 就必须在不再使用的时候调用1次CFRelease或者其他release函数 地图，蓝牙等框架的使用，在根据文档实现某地图，蓝牙相关功能的同时，我们需要注意内存的正确释放，大体需要注意的有需在使用完毕时将地图、代理等滞空为nil，注意地图中标注（大头针）的复用，保存蓝牙设备的数据源清空，使用完毕时清空标注数组等。 大数量的循环，该循环内产生大量的临时对象，直至循环结束才释放，可能导致内存泄漏，解决方法为在循环中创建自己的autoReleasePool，及时释放占用内存大的临时变量，减少内存占用峰值。 主线程死锁同步、异步 与 串行、并行的区别同步、异步： 指的是能否开启新的线程。同步不能开启新的线程，异步可以。 串行、并行： 指的是任务的执行方式。串行是指多个任务时，各个任务按顺序执行，完成一个之后才能进行下一个。并行指的是多个任务可以同时执行。异步是多个任务并行的前提条件。 并发和并行: 并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。 GCD 和 NSOperation 进行比较(1).NSOperation 是对 GCD 的封装，面相对象的类，GCD 只是一组方法 API。 (2).NSOperation 可以实现一些 GCD 中实现不了，或者实现比较复杂的功能。比如：设置最大并发数，设置线程间的依赖关系。 (3).实现某个多线程功能，使用 GCD，简单易用。实现某个多线程模块，使用 NSOperation，方便类的管理。 GCD全解https://www.jianshu.com/p/2d57c72016c6 strong和copy的区别代码示例 还是结合代码来说明这个情况 1234567891011121314151617181920@interface Person : NSObject@property (strong, nonatomic) NSArray *bookArray1;@property (copy, nonatomic) NSArray *bookArray2;@end@implementation Person//省略setter方法@end//Person调用main()&#123; NSMutableArray *books = [@[@&quot;book1&quot;] mutableCopy]; Person *person = [[Person alloc] init]; person.bookArray1 = books; person.bookArray2 = books; [books addObject:@&quot;book2&quot;]; NSLog(@&quot;bookArray1:%@&quot;,person.bookArray1); NSLog(@&quot;bookArray2:%@&quot;,person.bookArray2);&#125; 我们看到，使用strong修饰的person.bookArray1输出是[book1,book2]，而使用copy修饰的person.bookArray2输出是[book1]。这下可以看出来区别了吧。 备注：使用strong，则person.bookArray1与可变数组books指向同一块内存区域，books内容改变，导致person.bookArray1的内容改变，因为两者是同一个东西；而使用copy，person.bookArray2在赋值之前，将books内容复制，创建一个新的内存区域，所以两者不是一回事，books的改变不会导致person.bookArray2的改变。说到底，其实就是不同的修饰符，对应不同的setter方法， strong对应的setter方法，是将_property先release（_property release），然后将参数retain（property retain），最后是_property = property。 copy对应的setter方法，是将_property先release（_property release），然后拷贝参数内容（property copy），创建一块新的内存地址，最后_property = property。 retain是指针拷贝，copy是内容拷贝。在拷贝之前，都会释放旧的对象。 https://blog.csdn.net/haha_hello/article/details/67106284 NSSethttps://www.douban.com/note/609880170/https://www.jianshu.com/p/915356e280fc block的修饰词为什么选用copyhttps://www.cnblogs.com/jingxin1992/p/7145596.html 修改readonly属性的值kvc来设置1[stu setValue:@&quot;胡说&quot; forKey:NSStringFromSelector(@selector(hisName))]; 若想禁止kvc修改readonly属性的值，则可以在定义readonly属性的类中添加该方法 1234//默认返回为YES，表示可允许修改。改为NO即可+(BOOL)accessInstanceVariablesDirectly&#123; return NO;&#125; 总结: 当我们声明一个 readonly 的属性，外部可能会通过 KVC 修改该属性值。为了避免 KVC 修改属性值，须将定义属性所在类的类方法 + (BOOL)accessInstanceVariablesDirectly 重写，使其返回 NO. TCP三次握手和四次挥手https://blog.csdn.net/qzcsu/article/details/72861891 为什么assign不能用于修饰对象？首先我们需要明确，对象的内存一般被分配到堆上，基本数据类型和oc数据类型的内存一般被分配在栈上。 如果用assign修饰对象，当对象被释放后，指针的地址还是存在的，也就是说指针并没有被置为nil，从而造成了野指针。因为对象是分配在堆上的，堆上的内存由程序员分配释放。而因为指针没有被置为nil,如果后续的内存分配中，刚好分配到了这块内存，就会造成崩溃。如果用assign修饰对象，当对象释放后（因为不存在强引用，离开作用域对象内存可能被回收），指针的地址还是存在的，也就是说指针并没有被置为nil,下次再访问该对象就会造成野指针异常。对象是分配在堆上的，堆上的内存由程序员手动释放。 而assign修饰基本数据类型或oc数据类型，因为基本数据类型是分配在栈上的，由系统分配和释放，所以不会造成野指针。 在子线程中无法调用selector方法在子线程中无法调用selector方法这种情况是只有使用以下方法的时候才出现: 1- (void)performSelector:(SEL)aSelector withObject:(id)arg afterDelay:(NSTimeInterval)delay; 这是为什么呢？原因如下： 1、afterDelay方式是使用当前线程的RunLoop中根据afterDelay参数创建一个Timer定时器在一定时间后调用SEL，NO AfterDelay方式是直接调用SEL。 2、子线程中默认是没有runloop的，需要手动创建，只要调用获取当前线程RunLoop方法即可创建。 所以解决方法有两种： 创建子线程的runloop1234567dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [self performSelector:@selector(delayMethod) withObject:nil afterDelay:0]; [[NSRunLoop currentRunLoop] run]; NSLog(@&quot;调用方法＝＝开始&quot;); sleep(5); NSLog(@&quot;调用方法＝＝结束&quot;);&#125;); https://www.jianshu.com/p/672c0d4f435a NSThread、NSRunLoop 和 NSAutoreleasePool三者之间的关系NSThread 和 NSRunLoop是一一对应的关系在NSRunLoop对象的每个运行循环（event loop）开始前，系统会自动创建一个autoreleasepool，并在运行循环（event loop）结束时drain掉这个pool，同时释放所有autoreleased对象autoreleasepool只会对应一个线程，每个线程可能会对应多个autoreleasepool，比如autoreleasepool嵌套的情况 autorelease 实现原理https://blog.sunnyxx.com/2014/10/15/behind-autorelease/ atomic,nonatomic的内部底层原理探究atomic与nonatomicd的主要区别就是系统自动生成的getter/setter方法不一样 atomic系统自动生成的getter/setter方法会进行加锁操作nonatomic系统自动生成的getter/setter方法不会进行加锁操作 1、内部实现 在 objc4-723 的 Objective-C runtime 实现中，property 的 atomic 是采用 spinlock_t 也就是俗称的自旋锁实现的。 123456789101112131415161718192021222324252627282930313233// getterid objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) &#123; // ... if (!atomic) return *slot; // Atomic retain release world spinlock_t&amp; slotlock = PropertyLocks[slot]; slotlock.lock(); id value = objc_retain(*slot); slotlock.unlock(); // ...&#125;// setterstatic inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)&#123; // ... if (!atomic) &#123; oldValue = *slot; *slot = newValue; &#125; else &#123; spinlock_t&amp; slotlock = PropertyLocks[slot]; slotlock.lock(); oldValue = *slot; *slot = newValue; slotlock.unlock(); &#125; // ...&#125; 2、能否保证线程安全？ atomic通过这种方法，在运行时保证 set,get方法的原子性。仅仅是保证了set,get方法的原子性。这种线程是不安全的。 1234567891011121314151617@property (atomic, assign) int intA;//线程Afor (int i = 0; i &lt; 10000; i ++) &#123; self.intA = self.intA + 1; NSLog(@&quot;Thread A: %d\n&quot;, self.intA);&#125;//线程Bfor (int i = 0; i &lt; 10000; i ++) &#123; self.intA = self.intA + 1; NSLog(@&quot;Thread B: %d\n&quot;, self.intA);&#125; self.intA 是原子操作，但是self.intA = self.intA + 1这个表达式并不是原子操作。所以线程是不安全的。threadA 在执行表达式 self.intA之后 self.intA = self.intA + 1;并没有执行完毕此时threadB 执行self.intA = self.intA + 1;再回到threadA时，self.intA的数值就被更新了 所以仅仅使用atomic并不能保证线程安全。 网上还有其他实现，如同步锁1234567891011121314- (UITextField *) userName &#123; UITextField *retval = nil; @synchronized(self) &#123; retval = [[userName retain] autorelease]; &#125; return retval;&#125;- (void) setUserName:(UITextField *)userName_ &#123; @synchronized(self) &#123; [userName release]; userName = [userName_ retain]; &#125;&#125; atomic所说的线程安全只是保证了getter和setter存取方法的线程安全，并不能保证整个对象是线程安全的。 https://blog.csdn.net/CHENYUFENG1991/article/details/49687215 Swift相关Optional实质Optional Type 的本质是一个枚举类型，拆包其实相当于switch &amp; case123456789101112131415161718/// A type that can represent either a `Wrapped` value or `nil`, the absence/// of a value.public enum Optional&lt;Wrapped&gt; : _Reflectable, NilLiteralConvertible &#123; case None case Some(Wrapped) /// Construct a `nil` instance. public init() /// Construct a non-`nil` instance that stores `some`. public init(_ some: Wrapped) /// If `self == nil`, returns `nil`. Otherwise, returns `f(self!)`. @warn_unused_result public func map&lt;U&gt;(@noescape f: (Wrapped) throws -&gt; U) rethrows -&gt; U? /// Returns `nil` if `self` is `nil`, `f(self!)` otherwise. @warn_unused_result public func flatMap&lt;U&gt;(@noescape f: (Wrapped) throws -&gt; U?) rethrows -&gt; U? /// Create an instance initialized with `nil`. public init(nilLiteral: ())&#125; Swift - mutating关键字的使用Swift中protocol的功能比OC中强大很多，不仅能再class中实现，同时也适用于struct、enum。使用 mutating 关键字修饰方法是为了能在该方法中修改 struct 或是 enum 的变量，在设计接口的时候，也要考虑到使用者程序的扩展性。所以要多考虑使用mutating来修饰方法。 SDWebImage原理和缓存机制https://www.jianshu.com/p/7dea5b081d24https://blog.csdn.net/fucuiping_1314/article/details/79035138 利用CADisplayLink的与屏幕刷新同步调用的特性RunTime详解https://www.jianshu.com/p/6ebda3cd8052 moduleMaphttps://blog.dianqk.org/2017/05/01/dev-on-pod/]]></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式之结构型模式-适配器模式]]></title>
    <url>%2F2018%2F10%2F31%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[适配器模式通过引入适配器对两个组件进行适配，可以让两个API不兼容的组件协作。此模式可以将无法修改源码的组件集成到应用中，在使用第三方框架或利用另外一个项目输出的数据时，通常会遇到组件之间的兼容问题。 适配器模式相关概念意图： 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 解决： Extension或者适配器包装类，双向适配器 优点： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。 缺点： 过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。所以，适配器模式还是慎用。 适配器模式使用场景如下代码定义了 Employee 和 接口 EmployDataSource，员工信息12345678910struct Employee &#123; var name: String? var title: String?&#125;protocol EmployDataSource &#123; var employees: [Employee] &#123; get &#125; func search(name: String) -&gt; [Employee] func search(title: String) -&gt; [Employee]&#125; 实现DataSourceBase基类。12345678910111213141516171819202122232425262728293031323334353637383940414243class DataSourceBase: EmployDataSource &#123; var employees: [Employee] = [] fileprivate func search(filter: (Employee) -&gt; Bool) -&gt; [Employee] &#123; var results: [Employee] = [] for emp in employees &#123; if filter(emp) &#123; results.append(emp) &#125; &#125; return results &#125; func search(name: String) -&gt; [Employee] &#123; return search(filter: &#123; (employee) -&gt; Bool in return employee.name?.range(of: name) != nil &#125;) &#125; func search(title: String) -&gt; [Employee] &#123; return search(filter: &#123; (employee) -&gt; Bool in return employee.title?.range(of: title) != nil &#125;) &#125; &#125;//定义两个不同的部门class SalesDataSource: DataSourceBase &#123; override init() &#123; super.init() employees.append(Employee(name: "销售1", title: "VP")) employees.append(Employee(name: "销售2", title: "Account")) &#125;&#125;class DevelopmentDataSource: DataSourceBase &#123; override init() &#123; super.init() employees.append(Employee(name: "开发1", title: "iOS")) employees.append(Employee(name: "开发2", title: "Andorid")) &#125;&#125; 定义SearchTool用于对Employee的搜索。1234567891011121314151617181920212223242526272829303132class SearchTool &#123; enum SearchType &#123; case name case title &#125; fileprivate let sources: [EmployDataSource] //在init方法里我们可以对let的实例变量进行赋值，这是初始化方法的重要特点。 //在Swift中let声明的值是常量，无法被写入赋值，这对于构建线程安全的API十分有用。 //而因为Swift的init只可能被调用一次，因此在init中我们可以为常量进行赋值，而不会引起任何线程安全的问题. init(dataSource: EmployDataSource...) &#123; self.sources = dataSource &#125; var employees: [Employee] &#123; var results: [Employee] = [] for source in sources &#123; results += source.employees &#125; return results &#125; func search(text: String, searchType: SearchType) -&gt; [Employee] &#123; var results: [Employee] = [] for source in sources &#123; results += searchType == .name ? source.search(name: text) : source.search(title: text) &#125; return results &#125; &#125; 实现适配器模式假设要合并另外的员工数据（可能是某个开源或者不开源系统的数据），而另外的系统所定义的员工相关类并不兼容现有结构。如下代码：123456789101112131415161718class NewCoStaffMember &#123; fileprivate var name: String fileprivate var role: String init(name: String, role: String) &#123; self.name = name self.role = role &#125; func getName() -&gt; String &#123; return name &#125; func getRole() -&gt; String &#123; return role &#125;&#125; 1234567891011class NewCoDirectory &#123; fileprivate var staff: [String: NewCoStaffMember] init() &#123; staff = ["Hans": NewCoStaffMember(name: "Hans", role: "Crop Counsel"), "Feek": NewCoStaffMember(name: "Feek", role: "VIP")] &#125; func getStaff() -&gt; [String: NewCoStaffMember] &#123; return staff &#125;&#125; 适配器的Extension实现Swift实现适配器最优雅的方式是 Swift Extension, Extension为无法修改源码的类增加功能。即接口适配器模式：123456789101112131415161718192021222324252627extension NewCoDirectory: EmployDataSource &#123; var employees: [Employee] &#123; return getStaff().values.map(&#123; (servant) -&gt; Employee in return Employee(name: servant.getName(), title: servant.getRole()) &#125;) &#125; func search(name: String) -&gt; [Employee] &#123; return createEmployees(filter: &#123; (staff) -&gt; Bool in return staff.getName().range(of: name) != nil &#125;) &#125; func search(title: String) -&gt; [Employee] &#123; return createEmployees(filter: &#123; (staff) -&gt; Bool in return staff.getRole().range(of: title) != nil &#125;) &#125; fileprivate func createEmployees(filter filterClosure: (NewCoStaffMember) -&gt; Bool) -&gt; [Employee] &#123; return getStaff().values.filter(filterClosure).map &#123; (entry) -&gt; Employee in return Employee(name: entry.getName(), title: entry.getRole()) &#125; &#125; &#125; 这样，在SearchTool中，可以无缝使用其他已经被适配的结构。1234567891011let search = SearchTool(dataSource: SalesDataSource(), DevelopmentDataSource(), NewCoDirectory())print("----list----")for emp in search.employees &#123; print("\(emp.name) ")&#125; print("----search----") for emp in search.search(text: "VIP", searchType: .title) &#123; print("name = \(emp.name) title = \(emp.title)")&#125; 适配器的包装类实现使用对象适配器模式实现上述功能12345678910111213141516171819202122232425262728class NewCoDirectoryAdapter: EmployDataSource &#123; fileprivate let directory = NewCoDirectory() var employees: [Employee] &#123; return directory.getStaff().values.map(&#123; (servant) -&gt; Employee in return Employee(name: servant.getName(), title: servant.getRole()) &#125;) &#125; func search(name: String) -&gt; [Employee] &#123; return createEmployees(filter: &#123; (staff) -&gt; Bool in return staff.getName().range(of: name) != nil &#125;) &#125; func search(title: String) -&gt; [Employee] &#123; return createEmployees(filter: &#123; (staff) -&gt; Bool in return staff.getRole().range(of: title) != nil &#125;) &#125; fileprivate func createEmployees(filter filterClosure: (NewCoStaffMember) -&gt; Bool) -&gt; [Employee] &#123; return directory.getStaff().values.filter(filterClosure).map &#123; (entry) -&gt; Employee in return Employee(name: entry.getName(), title: entry.getRole()) &#125; &#125;&#125; 双向适配器Demo-应用及组件信息DrawingApp 为应用App，其中有绘图draw功能。12345678910111213141516protocol ShapeDrawer &#123; func drawShape()&#125;class DrawingApp &#123; let drawer: ShapeDrawer var cornerRadius: Int = 10 init(drawer: ShapeDrawer) &#123; self.drawer = drawer &#125; func makePicture() &#123; drawer.drawShape() &#125;&#125; SketchComponent 为绘图组件，其中包含一些图形信息。1234567891011121314151617181920protocol AppSettings &#123; var circleShape: Bool &#123; get &#125;&#125;class SketchComponent &#123; fileprivate let settings: AppSettings init(settings: AppSettings) &#123; self.settings = settings &#125; func sketchShape() &#123; if settings.circleShape &#123; print("Cicle") &#125; else &#123; print("Other") &#125; &#125;&#125; Demo-双向适配器实现应用中需要获取组件上shape信息，组件需要获取app中的cornerRadius信息 123456789101112131415class TwoWayAdapter: ShapeDrawer, AppSettings &#123; var app: DrawingApp? var component: SketchComponent? func drawShape() &#123; components?.sketchShape() &#125; var circleShape: Bool &#123; if let app = app &#123; return app.cornerRadius &gt; 0 &#125; return false &#125;&#125; 使用时： 12345678let twoWayAdapter = TwoWayAdapter()let app = DrawingApp(drawer: twoWayAdapter)let component = SketchComponent(settings: twoWayAdapter)twoWayAdapter.app = apptwoWayAdapter.component = component app.makePicture()]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>设计模式</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS有关WebView采坑总结]]></title>
    <url>%2F2018%2F10%2F31%2FWebView%E9%87%87%E5%9D%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[iOS中关于WKWebView和UIWebView区别及使用方式，网上资料很多，这里不再重复叙述，WKWebview文档，笔者曾对WebView相关做过组件化，有兴趣的可以参考 TBInteractiveProtocol。文档中有很多开发者未曾注意过的细节，例如，WebView方法调用的线程选择： 12ImportantCall WebKit functions and methods only from your app’s main thread or main dispatch queue. WebView加载线程如文档所述，WebKit的方法调用只能在主线程，如果不是，会导致白屏或者其他未知错误。例如Html片段如下：123DispatchQueue.main.async &#123; self.webView.loadHTMLString(html, baseURL: Bundle.main.bundleURL)&#125; WebView加载HTML片段BaseURL设置loadHTMLString方法中baseURL的设置一般设置为nil没什么问题，但是会出现 WebView 加载不上的现象，此时设置baseURL是一个好的选择，具体可参考 https://stackoverflow.com/questions/37013812/wkwebview-wont-loadhtmlstring WebView内容高度计算不准确高度计算一般使用stringByEvaluatingJavaScript获取。123if let height = webView.stringByEvaluatingJavaScript(from: "document.body.scrollHeight")?.toFloat() &#123; //webview高度&#125; 其中toFloat()方法的定义：123456789extension String &#123; public func toFloat() -&gt; Float? &#123; if let num = NumberFormatter().number(from: self) &#123; return num.floatValue &#125; else &#123; return nil &#125; &#125;&#125; 对于scrollHeight、offSetHeight的区别，可参考 图解scrollHeight, clientHeight, offsetHeight, scrollTop以及获取方法 以及其他相关文章。但是会发现，此时的高度并不准确，原因在于html片段，并没有设置meta标签，一般的meta标签设置如下：1"&lt;meta name=\"viewport\" content=\"width=device-width",initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no\" /&gt;" 其中width设置的是device-width，也就是屏幕宽度，但是实际上，WebView的加载并不是完全等于device-width，所以该字段应该根据实际的WebView宽度进行设置。123func formateHtml(width: String = "device-width") -&gt; String &#123; return "&lt;meta name=\"viewport\" content=\"width=" + width + ",initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no\" /&gt;"&#125; Cell中WebView的复用高度记录一般对于WebView的复用问题，首先要记录加载之后的高度，或者是预处理计算高度。1fileprivate var valueHeights: [IndexPath: CGFloat] = [:] 反向刷新123456789//block可自行定义cell?.caculateWebViewHeightBlock = &#123; [weak self] (height) in guard let `self` = self else &#123; return &#125; self.valueHeights[indexPath] = height //需要记录高度,刷新cell高度 self.tableView.reloadData()&#125; 高度再次传入Cell进行控制，注意如果已知高度，则不需要在loadHtml之后调用block回传高度，否则会死循环！！！！！！ 如果不存在复用，则可以提前计算加载的高度，然后直接刷新视图。笔者的CaculateWebViewManager类可作参考。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import UIKitimport WebKittypealias CaculateWebViewHeightBlock = ((_ height: CGFloat) -&gt; Void)class CaculateWebViewManager: NSObject &#123; fileprivate var caculateWebView: WKWebView! fileprivate var heightBlock: CaculateWebViewHeightBlock? override init() &#123; super.init() caculateWebView = WKWebView(frame: CGRect(x: 0, y: 0, w: kAdaptScreenWidth, h: 0)) caculateWebView.navigationDelegate = self &#125; func caculateHeight(width: CGFloat, html: String, heightBlock: CaculateWebViewHeightBlock?) &#123; self.heightBlock = heightBlock caculateWebView.frame = CGRect(x: 0, y: 0, w: width, h: 10) caculateWebView.loadHTMLString(html, baseURL: Bundle.main.bundleURL) &#125; class func fetchDetailHtml(searchTopicWordsRecord: KnowleadgeDetailContentModel?, width: CGFloat) -&gt; (String, CGFloat) &#123; let tWidth = width - 12 if let record = searchTopicWordsRecord &#123; var html = "" let htmlMeta = formateHtml(width: "\(Int(tWidth))px") if record.subjectId == "1" &#123; html = "\(htmlMeta)&lt;p style=\"font-size:16px;text-align:center;\"&gt;\(record.description)&lt;/p&gt;" &#125; else &#123; html = "\(htmlMeta)\(record.richDescription)" &#125; return (html, tWidth) &#125; return ("", tWidth) &#125; class func fetchSplitAssociateHtml(type: Int, subjectId: String, splitOrAssociate: String?, width: CGFloat) -&gt; (String, CGFloat) &#123; let tWidth = width - 15 let htmlMeta = formateHtml(width: "\(Int(tWidth))px") if splitOrAssociate != "" &amp;&amp; type == 0 &amp;&amp; subjectId == "1" &#123; var html = "\(htmlMeta)" let array = splitOrAssociate!.components(separatedBy: "~") for (index, item) in array.enumerated() &#123; if index%2 == 1 &#123; html.append("&amp;nbsp&lt;span style=\"color: red;\"&gt;\(item)&lt;/span&gt;&amp;nbsp") &#125; else &#123; html.append(item) &#125; &#125; return (html, tWidth) &#125; if let splitOrAssociate = splitOrAssociate &#123; let split = "\(htmlMeta)\(splitOrAssociate)" return (split, tWidth) &#125; return ("", tWidth) &#125; &#125;extension CaculateWebViewManager: WKNavigationDelegate &#123; func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!) &#123; &#125; func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) &#123; webView.evaluateJavaScript("document.body.scrollHeight", completionHandler: &#123; [weak self] (result, error) in guard let `self` = self else &#123; return &#125; var webViewHeight = CGFloat(40.0) if let height = result &#123; webViewHeight = CGFloat(height as! Float) &#125; self.heightBlock?(webViewHeight) &#125;) &#125; func webView(_ webView: WKWebView, didFail navigation: WKNavigation!, withError error: Error) &#123; &#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>WebView</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub+Hexo+Next博客搭建实战及优化]]></title>
    <url>%2F2018%2F10%2F18%2FGitHub%2BHexo%2BNext%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%88%98%E5%8F%8A%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[我的个人博客链接：jingtaotao.top本文是针对有一定编程基础的Coder，采坑完善后的文章。 本文描述概念1、文中 yourname 指的是GitHub账号，比如笔者的 jingtao910429。2、文中 主目录 指的是 Hexo 目录。3、文中 站点配置文件 指的是 主目录 下的 _config.yml 文件。4、文中 主题目录 指的是 themes/next 目录。(Next配置主题时会涉及,如果是yilia主题，则是themes/yilia,其他主题同上)5、文中 主题配置文件 指的是 themes 目录下的 _config.yml 文件。 博客搭建基础Node.jswindows https://nodejs.org/en/ 下载安装。Linux 执行命令 sudo apt-get install nodejs Gitwindows https://github.com/waylau/git-for-win 安装。Linux 执行命令 sudo apt-get install git Hexo首先列出常用 Hexo 命令：12345$ hexo generate # 启动本地服务器$ hexo server # 在浏览器输入 http://localhost:4000/就可以看见网页和模板了$ hexo new &quot;文章名&quot; #新建文章$ hexo new page &quot;页面名&quot; #新建页面$ hexo deploy #发布到远端 对应的简写命令：1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 新建文件夹，安装 Hexo。进入Hexo安装目录，依次执行如下命令： npm install hexo-cli -g hexo init 初始化网站，此时，安装目录为 Hexo 主目录。也可以使用 hexo init blogCategory, 注意 blogCategory是Hexo安装目录下的二级目录，如果使用二级目录安装 Hexo 那么 Hexo 的主目录就是二级目录。 hexo s 浏览器打开 http://localhost:4000/ 预览网页。 GitHub配置部署GitHub创建Repositories创建如图的GitHub.io仓库，注意：yourname.github.io中yourname和Github上对应，如下图： 将主目录下_config.yml中的deploy修改如下：12345deploy: type: git repo: git@github.com:yourname/yourname.github.io.git #这里的网址填你自己的，这里使用的SSH地址，也可以使用https branch: master SSH执行命令 ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot; enter即可。秘钥生成完毕，会得到两个文件id_rsa和id_rsa.pub, vim id_rsa.pub打开文件，copy。进入 https://github.com/settings/ssh 将复制的内容粘贴到Key的输入框，title任意。 hexo deploy 出错修正，多数博客未涉及解决方案 deploy not found： git解决方案：执行 npm install hexo-deployer-git --save 语句后， 再部署即可。该语句执行后可能会出现12ERROR Local hexo not foundERROR Try running: &apos;npm install hexo --save&apos; 导致这个原因为在自己的博客文件夹中,.gitignore文件中添加了node_modules/,导致更新的时候,这个文件夹被忽略，没有被更新上去。 解决方案: 1、 cmd进入主目录 2、 执行 npm install 3、 执行 hexo server 4、 执行成功后，再到博客下的git中执行 Hexo 命令可以执行成功。 添加主题Next主题添加cd 到主目录下，然后执行。1git clone https://github.com/iissnan/hexo-theme-next themes/next 编辑站点配置文件中theme属性，将其由landscape改为next。在主目录执行部署Hexo指令：123456// 清理缓存hexo clean// 生成文件hexo generate// 部署hexo deploy yilia主题添加添加yilia主题，可以参考 我是如何利用Github Pages搭建起我的博客，细数一路的坑 主题优化主题具体优化可参考 Hexo搭建的GitHub博客之优化其中有几个地方对于Coder来说比较重要的笔者没有涉及到: 1、标题之间间隔，行间隔2、背景圆角3、Gemini透明度设置4、代码Copy功能5、代码折叠6、gitalk集成中比较容易出错的地方 针对以上问题，下面列出解决方案 标题之间间隔，行间隔在Next主题下，是没有对post-body下的p, h1, h2, h3, h4, h5, h6, ul设置相应的样式，所以产生user agent stylesheet浏览器默认样式表,所以打开\themes\next\source\css\_custom\custom.styl下添加代码：1234.post-body p, h1, h2, h3, h4, h5, h6, ul &#123; margin-block-start: 0.3em; margin-block-end: 0.3em;&#125; 打开\themes\next\source\css\_custom\components\post\post-expand.styl修改代码：1234567891011121314151617181920212223242526272829303132333435.posts-expand .post-body &#123; +desktop() &#123; text-align: justify; &#125; h2, h3, h4, h5, h6 &#123; //此处可以控制top和bottom的值，来符合页面要求 padding-top: 10px; //padding-bottom: 5px; .header-anchor&#123; float: right; margin-left: 10px; color: $grey-light; border-bottom-style: none; visibility: hidden; &amp;:hover&#123; color: inherit; &#125; &#125; &amp;:hover .header-anchor&#123; visibility: visible; &#125; &#125; ul li &#123; list-style: circle; &#125; img &#123; box-sizing: border-box; margin: auto; padding: 3px; border: 1px solid $gray-lighter; &#125;&#125; 背景圆角打开\themes\next\source\css\_variables\Gemini.styl下添加代码：12$border-radius-inner = 10px //圆角设置$border-radius = 10px //圆角设置 Gemini透明度设置主要是通过修改CSS样式来实现1、文章部分 themes/next/source/css/_schemes/Gemini/index.styl123456.post-block &#123; padding: $content-desktop-padding; background: rgba(255,255,255,0.7); box-shadow: $box-shadow-inner; border-radius: $border-radius-inner;&#125; 2、阅读全文按钮 /themes/next/source/css/_variables/Pisces.styl123456$btn-default-radius = 2px$btn-default-bg = rgba(255,255,255,0.5)$btn-default-color = $text-color$btn-default-border-color = $text-color$btn-default-hover-color = white$btn-default-hover-bg = $black-deep 3、分页部分 /themes/next/source/css/_schemes/Gemini/index.styl1234567891011.pagination &#123; .prev, .next, .page-number &#123; margin-bottom: initial; top: initial; &#125; margin: sboffset 0 0; background: rgba(255,255,255,0.7); box-shadow: $box-shadow; border-radius: $border-radius; padding: 10px 0 10px;&#125; 4、评论区部分 /themes/next/source/css/_schemes/Gemini/index.styl12345678.comments &#123; padding: $content-desktop-padding; margin: initial; margin-top: sboffset; background: rgba(255,255,255,0.7); box-shadow: $box-shadow; border-radius: $border-radius;&#125; 5、侧栏菜单界面 /themes/next/source/css/_schemes/Pisces/_layout.styl123456789101112131415161718192021222324.header-inner &#123; position: absolute; top: 0; overflow: hidden; padding: 0; width: $sidebar-desktop; background: rgba(255,255,255,0.7); box-shadow: $box-shadow-inner; border-radius: $border-radius-inner; +desktop-large() &#123; .container &amp; &#123; width: $sidebar-desktop; &#125; &#125; +tablet() &#123; position: relative; width: auto; border-radius: initial; &#125; +mobile() &#123; position: relative; width: auto; border-radius: initial; &#125;&#125; 6、个人资料界面 /themes/next/source/css/_schemes/Pisces/_sidebar.styl1234567891011121314.sidebar-inner &#123;//padding: 20px 10px 0; box-sizing: border-box; width: $sidebar-desktop; color: $text-color; background: rgba(255,255,255,0.7); box-shadow: $box-shadow; border-radius: $border-radius; if (hexo-config('motion.enable') and hexo-config('motion.transition.sidebar')) &#123; opacity: 0; &#125; &amp;.affix &#123; position: fixed; top: $sidebar-offset; &#125; 其他Next主题请参考修改。 代码Copy功能参考 HEXO优化之（二）—-添加复制功能 功能添加出现Clipboard is not defined错误，需要修改一下Clipboard的源码，123var Clipboard = fuction()&#123;....&#125;;//在Clipboard定义后面增加$.Clipboard = Clipboard;//这是我增加的代码 使用时代码1234567891011121314var clipboard = new $.Clipboard('.btn', &#123; text: function() &#123; //var ue = UM.getEditor('txtContent',&#123;&#125;); //ue.queryCommandValue( 'insertcode' ); return $("#"+domId).val(); &#125;&#125;);clipboard.on('success', function(e) &#123; //console.log(e); e.clearSelection();&#125;);clipboard.on('error', function(e) &#123; //console.log(e);&#125;); 代码折叠主要参考 Hexo Next博客添加折叠块功能添加折叠代码块 Gitalk集成中比较容易出错的地方主要参考 Hexo NexT主题中集成gitalk评论系统基本可以顺利集成下来，但是有几个概念笔者并没有阐述清楚： Homepage URL 和 Authorization callback URL的设置问题这两个值对应的是站点地址，也就是对外的访问网址，比如 https://jingtao910429.github.io,如果绑定了域名信息，则是个人域名，比如 https://jingtaotao.top 主目录配置中的repo设置repo 对应的是GitHub上的repo地址，比如 jingtao910429.github.io]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Hexo+Next</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式之结构型模式-适配器模式]]></title>
    <url>%2F2018%2F10%2F31%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[适配器模式通过引入适配器对两个组件进行适配，可以让两个API不兼容的组件协作。此模式可以将无法修改源码的组件集成到应用中，在使用第三方框架或利用另外一个项目输出的数据时，通常会遇到组件之间的兼容问题。 适配器模式相关概念意图： 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 解决： Extension或者适配器包装类，双向适配器 优点： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。 缺点： 过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 适配器模式使用场景如下代码定义了 Employee 和 接口 EmployDataSource，员工信息12345678910struct Employee &#123; var name: String? var title: String?&#125;protocol EmployDataSource &#123; var employees: [Employee] &#123; get &#125; func search(name: String) -&gt; [Employee] func search(title: String) -&gt; [Employee]&#125; 实现DataSourceBase基类。12345678910111213141516171819202122232425262728293031323334353637383940414243class DataSourceBase: EmployDataSource &#123; var employees: [Employee] = [] fileprivate func search(filter: (Employee) -&gt; Bool) -&gt; [Employee] &#123; var results: [Employee] = [] for emp in employees &#123; if filter(emp) &#123; results.append(emp) &#125; &#125; return results &#125; func search(name: String) -&gt; [Employee] &#123; return search(filter: &#123; (employee) -&gt; Bool in return employee.name?.range(of: name) != nil &#125;) &#125; func search(title: String) -&gt; [Employee] &#123; return search(filter: &#123; (employee) -&gt; Bool in return employee.title?.range(of: title) != nil &#125;) &#125; &#125;//定义两个不同的部门class SalesDataSource: DataSourceBase &#123; override init() &#123; super.init() employees.append(Employee(name: "销售1", title: "VP")) employees.append(Employee(name: "销售2", title: "Account")) &#125;&#125;class DevelopmentDataSource: DataSourceBase &#123; override init() &#123; super.init() employees.append(Employee(name: "开发1", title: "iOS")) employees.append(Employee(name: "开发2", title: "Andorid")) &#125;&#125; 定义SearchTool用于对Employee的搜索。1234567891011121314151617181920212223242526272829303132class SearchTool &#123; enum SearchType &#123; case name case title &#125; fileprivate let sources: [EmployDataSource] //在init方法里我们可以对let的实例变量进行赋值，这是初始化方法的重要特点。 //在Swift中let声明的值是常量，无法被写入赋值，这对于构建线程安全的API十分有用。 //而因为Swift的init只可能被调用一次，因此在init中我们可以为常量进行赋值，而不会引起任何线程安全的问题. init(dataSource: EmployDataSource...) &#123; self.sources = dataSource &#125; var employees: [Employee] &#123; var results: [Employee] = [] for source in sources &#123; results += source.employees &#125; return results &#125; func search(text: String, searchType: SearchType) -&gt; [Employee] &#123; var results: [Employee] = [] for source in sources &#123; results += searchType == .name ? source.search(name: text) : source.search(title: text) &#125; return results &#125; &#125; 实现适配器模式假设要合并另外的员工数据（可能是某个开源或者不开源系统的数据），而另外的系统所定义的员工相关类并不兼容现有结构。如下代码：123456789101112131415161718class NewCoStaffMember &#123; fileprivate var name: String fileprivate var role: String init(name: String, role: String) &#123; self.name = name self.role = role &#125; func getName() -&gt; String &#123; return name &#125; func getRole() -&gt; String &#123; return role &#125;&#125; 1234567891011class NewCoDirectory &#123; fileprivate var staff: [String: NewCoStaffMember] init() &#123; staff = ["Hans": NewCoStaffMember(name: "Hans", role: "Crop Counsel"), "Feek": NewCoStaffMember(name: "Feek", role: "VIP")] &#125; func getStaff() -&gt; [String: NewCoStaffMember] &#123; return staff &#125;&#125; 适配器的Extension实现Swift实现适配器最优雅的方式是 Swift Extension, Extension为无法修改源码的类增加功能。即接口适配器模式：123456789101112131415161718192021222324252627extension NewCoDirectory: EmployDataSource &#123; var employees: [Employee] &#123; return getStaff().values.map(&#123; (servant) -&gt; Employee in return Employee(name: servant.getName(), title: servant.getRole()) &#125;) &#125; func search(name: String) -&gt; [Employee] &#123; return createEmployees(filter: &#123; (staff) -&gt; Bool in return staff.getName().range(of: name) != nil &#125;) &#125; func search(title: String) -&gt; [Employee] &#123; return createEmployees(filter: &#123; (staff) -&gt; Bool in return staff.getRole().range(of: title) != nil &#125;) &#125; fileprivate func createEmployees(filter filterClosure: (NewCoStaffMember) -&gt; Bool) -&gt; [Employee] &#123; return getStaff().values.filter(filterClosure).map &#123; (entry) -&gt; Employee in return Employee(name: entry.getName(), title: entry.getRole()) &#125; &#125; &#125; 这样，在SearchTool中，可以无缝使用其他已经被适配的结构。1234567891011let search = SearchTool(dataSource: SalesDataSource(), DevelopmentDataSource(), NewCoDirectory())print("----list----")for emp in search.employees &#123; print("\(emp.name) ")&#125; print("----search----") for emp in search.search(text: "VIP", searchType: .title) &#123; print("name = \(emp.name) title = \(emp.title)")&#125; 适配器的包装类实现使用对象适配器模式实现上述功能12345678910111213141516171819202122232425262728class NewCoDirectoryAdapter: EmployDataSource &#123; fileprivate let directory = NewCoDirectory() var employees: [Employee] &#123; return directory.getStaff().values.map(&#123; (servant) -&gt; Employee in return Employee(name: servant.getName(), title: servant.getRole()) &#125;) &#125; func search(name: String) -&gt; [Employee] &#123; return createEmployees(filter: &#123; (staff) -&gt; Bool in return staff.getName().range(of: name) != nil &#125;) &#125; func search(title: String) -&gt; [Employee] &#123; return createEmployees(filter: &#123; (staff) -&gt; Bool in return staff.getRole().range(of: title) != nil &#125;) &#125; fileprivate func createEmployees(filter filterClosure: (NewCoStaffMember) -&gt; Bool) -&gt; [Employee] &#123; return directory.getStaff().values.filter(filterClosure).map &#123; (entry) -&gt; Employee in return Employee(name: entry.getName(), title: entry.getRole()) &#125; &#125;&#125; 双向适配器Demo-应用及组件信息DrawingApp 为应用App，其中有绘图draw功能。12345678910111213141516protocol ShapeDrawer &#123; func drawShape()&#125;class DrawingApp &#123; let drawer: ShapeDrawer var cornerRadius: Int = 10 init(drawer: ShapeDrawer) &#123; self.drawer = drawer &#125; func makePicture() &#123; drawer.drawShape() &#125;&#125; SketchComponent 为绘图组件，其中包含一些图形信息。1234567891011121314151617181920protocol AppSettings &#123; var circleShape: Bool &#123; get &#125;&#125;class SketchComponent &#123; fileprivate let settings: AppSettings init(settings: AppSettings) &#123; self.settings = settings &#125; func sketchShape() &#123; if settings.circleShape &#123; print("Cicle") &#125; else &#123; print("Other") &#125; &#125;&#125; Demo-双向适配器实现应用中需要获取组件上shape信息，组件需要获取app中的cornerRadius信息 123456789101112131415class TwoWayAdapter: ShapeDrawer, AppSettings &#123; var app: DrawingApp? var component: SketchComponent? func drawShape() &#123; components?.sketchShape() &#125; var circleShape: Bool &#123; if let app = app &#123; return app.cornerRadius &gt; 0 &#125; return false &#125;&#125; 使用时： 12345678let twoWayAdapter = TwoWayAdapter()let app = DrawingApp(drawer: twoWayAdapter)let component = SketchComponent(settings: twoWayAdapter)twoWayAdapter.app = apptwoWayAdapter.component = component app.makePicture()]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>设计模式</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS有关WebView采坑总结]]></title>
    <url>%2F2018%2F10%2F31%2FWebView%E9%87%87%E5%9D%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[iOS中关于WKWebView和UIWebView区别及使用方式，网上资料很多，这里不再重复叙述，WKWebview文档，笔者曾对WebView相关做过组件化，有兴趣的可以参考 TBInteractiveProtocol。文档中有很多开发者未曾注意过的细节，例如，WebView方法调用的线程选择： 12ImportantCall WebKit functions and methods only from your app’s main thread or main dispatch queue. WebView加载线程如文档所述，WebKit的方法调用只能在主线程，如果不是，会导致白屏或者其他未知错误。例如Html片段如下：123DispatchQueue.main.async &#123; self.webView.loadHTMLString(html, baseURL: Bundle.main.bundleURL)&#125; WebView加载HTML片段BaseURL设置loadHTMLString方法中baseURL的设置一般设置为nil没什么问题，但是会出现 WebView 加载不上的现象，此时设置baseURL是一个好的选择，具体可参考 https://stackoverflow.com/questions/37013812/wkwebview-wont-loadhtmlstring WebView内容高度计算不准确高度计算一般使用stringByEvaluatingJavaScript获取。123if let height = webView.stringByEvaluatingJavaScript(from: "document.body.scrollHeight")?.toFloat() &#123; //webview高度&#125; 其中toFloat()方法的定义：123456789extension String &#123; public func toFloat() -&gt; Float? &#123; if let num = NumberFormatter().number(from: self) &#123; return num.floatValue &#125; else &#123; return nil &#125; &#125;&#125; 对于scrollHeight、offSetHeight的区别，可参考 图解scrollHeight, clientHeight, offsetHeight, scrollTop以及获取方法 以及其他相关文章。但是会发现，此时的高度并不准确，原因在于html片段，并没有设置meta标签，一般的meta标签设置如下：1"&lt;meta name=\"viewport\" content=\"width=device-width",initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no\" /&gt;" 其中width设置的是device-width，也就是屏幕宽度，但是实际上，WebView的加载并不是完全等于device-width，所以该字段应该根据实际的WebView宽度进行设置。123func formateHtml(width: String = "device-width") -&gt; String &#123; return "&lt;meta name=\"viewport\" content=\"width=" + width + ",initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no\" /&gt;"&#125; Cell中WebView的复用高度记录一般对于WebView的复用问题，首先要记录加载之后的高度，或者是预处理计算高度。1fileprivate var valueHeights: [IndexPath: CGFloat] = [:] 反向刷新123456789//block可自行定义cell?.caculateWebViewHeightBlock = &#123; [weak self] (height) in guard let `self` = self else &#123; return &#125; self.valueHeights[indexPath] = height //需要记录高度,刷新cell高度 self.tableView.reloadData()&#125; 高度再次传入Cell进行控制，注意如果已知高度，则不需要在loadHtml之后调用block回传高度，否则会死循环！！！！！！ 如果不存在复用，则可以提前计算加载的高度，然后直接刷新视图。笔者的CaculateWebViewManager类可作参考。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import UIKitimport WebKittypealias CaculateWebViewHeightBlock = ((_ height: CGFloat) -&gt; Void)class CaculateWebViewManager: NSObject &#123; fileprivate var caculateWebView: WKWebView! fileprivate var heightBlock: CaculateWebViewHeightBlock? override init() &#123; super.init() caculateWebView = WKWebView(frame: CGRect(x: 0, y: 0, w: kAdaptScreenWidth, h: 0)) caculateWebView.navigationDelegate = self &#125; func caculateHeight(width: CGFloat, html: String, heightBlock: CaculateWebViewHeightBlock?) &#123; self.heightBlock = heightBlock caculateWebView.frame = CGRect(x: 0, y: 0, w: width, h: 10) caculateWebView.loadHTMLString(html, baseURL: Bundle.main.bundleURL) &#125; class func fetchDetailHtml(searchTopicWordsRecord: KnowleadgeDetailContentModel?, width: CGFloat) -&gt; (String, CGFloat) &#123; let tWidth = width - 12 if let record = searchTopicWordsRecord &#123; var html = "" let htmlMeta = formateHtml(width: "\(Int(tWidth))px") if record.subjectId == "1" &#123; html = "\(htmlMeta)&lt;p style=\"font-size:16px;text-align:center;\"&gt;\(record.description)&lt;/p&gt;" &#125; else &#123; html = "\(htmlMeta)\(record.richDescription)" &#125; return (html, tWidth) &#125; return ("", tWidth) &#125; class func fetchSplitAssociateHtml(type: Int, subjectId: String, splitOrAssociate: String?, width: CGFloat) -&gt; (String, CGFloat) &#123; let tWidth = width - 15 let htmlMeta = formateHtml(width: "\(Int(tWidth))px") if splitOrAssociate != "" &amp;&amp; type == 0 &amp;&amp; subjectId == "1" &#123; var html = "\(htmlMeta)" let array = splitOrAssociate!.components(separatedBy: "~") for (index, item) in array.enumerated() &#123; if index%2 == 1 &#123; html.append("&amp;nbsp&lt;span style=\"color: red;\"&gt;\(item)&lt;/span&gt;&amp;nbsp") &#125; else &#123; html.append(item) &#125; &#125; return (html, tWidth) &#125; if let splitOrAssociate = splitOrAssociate &#123; let split = "\(htmlMeta)\(splitOrAssociate)" return (split, tWidth) &#125; return ("", tWidth) &#125; &#125;extension CaculateWebViewManager: WKNavigationDelegate &#123; func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!) &#123; &#125; func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) &#123; webView.evaluateJavaScript("document.body.scrollHeight", completionHandler: &#123; [weak self] (result, error) in guard let `self` = self else &#123; return &#125; var webViewHeight = CGFloat(40.0) if let height = result &#123; webViewHeight = CGFloat(height as! Float) &#125; self.heightBlock?(webViewHeight) &#125;) &#125; func webView(_ webView: WKWebView, didFail navigation: WKNavigation!, withError error: Error) &#123; &#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>WebView</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub+Hexo+Next博客搭建实战及优化]]></title>
    <url>%2F2018%2F10%2F18%2FGitHub%2BHexo%2BNext%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%88%98%E5%8F%8A%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[我的个人博客链接：jingtaotao.top本文是针对有一定编程基础的Coder，采坑完善后的文章。 本文描述概念1、文中 yourname 指的是GitHub账号，比如笔者的 jingtao910429。2、文中 主目录 指的是 Hexo 目录。3、文中 站点配置文件 指的是 主目录 下的 _config.yml 文件。4、文中 主题目录 指的是 themes/next 目录。(Next配置主题时会涉及,如果是yilia主题，则是themes/yilia,其他主题同上)5、文中 主题配置文件 指的是 themes 目录下的 _config.yml 文件。 博客搭建基础Node.jswindows https://nodejs.org/en/ 下载安装。Linux 执行命令 sudo apt-get install nodejs Gitwindows https://github.com/waylau/git-for-win 安装。Linux 执行命令 sudo apt-get install git Hexo首先列出常用 Hexo 命令：12345$ hexo generate # 启动本地服务器$ hexo server # 在浏览器输入 http://localhost:4000/就可以看见网页和模板了$ hexo new &quot;文章名&quot; #新建文章$ hexo new page &quot;页面名&quot; #新建页面$ hexo deploy #发布到远端 对应的简写命令：1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 新建文件夹，安装 Hexo。进入Hexo安装目录，依次执行如下命令： npm install hexo-cli -g hexo init 初始化网站，此时，安装目录为 Hexo 主目录。也可以使用 hexo init blogCategory, 注意 blogCategory是Hexo安装目录下的二级目录，如果使用二级目录安装 Hexo 那么 Hexo 的主目录就是二级目录。 hexo s 浏览器打开 http://localhost:4000/ 预览网页。 GitHub配置部署GitHub创建Repositories创建如图的GitHub.io仓库，注意：yourname.github.io中yourname和Github上对应，如下图： 将主目录下_config.yml中的deploy修改如下：12345deploy: type: git repo: git@github.com:yourname/yourname.github.io.git #这里的网址填你自己的，这里使用的SSH地址，也可以使用https branch: master SSH执行命令 ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot; enter即可。秘钥生成完毕，会得到两个文件id_rsa和id_rsa.pub, vim id_rsa.pub打开文件，copy。进入 https://github.com/settings/ssh 将复制的内容粘贴到Key的输入框，title任意。 hexo deploy 出错修正，多数博客未涉及解决方案 deploy not found： git解决方案：执行 npm install hexo-deployer-git --save 语句后， 再部署即可。该语句执行后可能会出现12ERROR Local hexo not foundERROR Try running: &apos;npm install hexo --save&apos; 导致这个原因为在自己的博客文件夹中,.gitignore文件中添加了node_modules/,导致更新的时候,这个文件夹被忽略，没有被更新上去。 解决方案: 1、 cmd进入主目录 2、 执行 npm install 3、 执行 hexo server 4、 执行成功后，再到博客下的git中执行 Hexo 命令可以执行成功。 添加主题Next主题添加cd 到主目录下，然后执行。1git clone https://github.com/iissnan/hexo-theme-next themes/next 编辑站点配置文件中theme属性，将其由landscape改为next。在主目录执行部署Hexo指令：123456// 清理缓存hexo clean// 生成文件hexo generate// 部署hexo deploy yilia主题添加添加yilia主题，可以参考 我是如何利用Github Pages搭建起我的博客，细数一路的坑 主题优化主题具体优化可参考 Hexo搭建的GitHub博客之优化其中有几个地方对于Coder来说比较重要的笔者没有涉及到: 1、标题之间间隔，行间隔2、背景圆角3、Gemini透明度设置4、代码Copy功能5、代码折叠6、gitalk集成中比较容易出错的地方 针对以上问题，下面列出解决方案 标题之间间隔，行间隔在Next主题下，是没有对post-body下的p, h1, h2, h3, h4, h5, h6, ul设置相应的样式，所以产生user agent stylesheet浏览器默认样式表,所以打开\themes\next\source\css\_custom\custom.styl下添加代码：1234.post-body p, h1, h2, h3, h4, h5, h6, ul &#123; margin-block-start: 0.3em; margin-block-end: 0.3em;&#125; 打开\themes\next\source\css\_custom\components\post\post-expand.styl修改代码：1234567891011121314151617181920212223242526272829303132333435.posts-expand .post-body &#123; +desktop() &#123; text-align: justify; &#125; h2, h3, h4, h5, h6 &#123; //此处可以控制top和bottom的值，来符合页面要求 padding-top: 10px; //padding-bottom: 5px; .header-anchor&#123; float: right; margin-left: 10px; color: $grey-light; border-bottom-style: none; visibility: hidden; &amp;:hover&#123; color: inherit; &#125; &#125; &amp;:hover .header-anchor&#123; visibility: visible; &#125; &#125; ul li &#123; list-style: circle; &#125; img &#123; box-sizing: border-box; margin: auto; padding: 3px; border: 1px solid $gray-lighter; &#125;&#125; 背景圆角打开\themes\next\source\css\_variables\Gemini.styl下添加代码：12$border-radius-inner = 10px //圆角设置$border-radius = 10px //圆角设置 Gemini透明度设置主要是通过修改CSS样式来实现1、文章部分 themes/next/source/css/_schemes/Gemini/index.styl123456.post-block &#123; padding: $content-desktop-padding; background: rgba(255,255,255,0.7); box-shadow: $box-shadow-inner; border-radius: $border-radius-inner;&#125; 2、阅读全文按钮 /themes/next/source/css/_variables/Pisces.styl123456$btn-default-radius = 2px$btn-default-bg = rgba(255,255,255,0.5)$btn-default-color = $text-color$btn-default-border-color = $text-color$btn-default-hover-color = white$btn-default-hover-bg = $black-deep 3、分页部分 /themes/next/source/css/_schemes/Gemini/index.styl1234567891011.pagination &#123; .prev, .next, .page-number &#123; margin-bottom: initial; top: initial; &#125; margin: sboffset 0 0; background: rgba(255,255,255,0.7); box-shadow: $box-shadow; border-radius: $border-radius; padding: 10px 0 10px;&#125; 4、评论区部分 /themes/next/source/css/_schemes/Gemini/index.styl12345678.comments &#123; padding: $content-desktop-padding; margin: initial; margin-top: sboffset; background: rgba(255,255,255,0.7); box-shadow: $box-shadow; border-radius: $border-radius;&#125; 5、侧栏菜单界面 /themes/next/source/css/_schemes/Pisces/_layout.styl123456789101112131415161718192021222324.header-inner &#123; position: absolute; top: 0; overflow: hidden; padding: 0; width: $sidebar-desktop; background: rgba(255,255,255,0.7); box-shadow: $box-shadow-inner; border-radius: $border-radius-inner; +desktop-large() &#123; .container &amp; &#123; width: $sidebar-desktop; &#125; &#125; +tablet() &#123; position: relative; width: auto; border-radius: initial; &#125; +mobile() &#123; position: relative; width: auto; border-radius: initial; &#125;&#125; 6、个人资料界面 /themes/next/source/css/_schemes/Pisces/_sidebar.styl1234567891011121314.sidebar-inner &#123;//padding: 20px 10px 0; box-sizing: border-box; width: $sidebar-desktop; color: $text-color; background: rgba(255,255,255,0.7); box-shadow: $box-shadow; border-radius: $border-radius; if (hexo-config('motion.enable') and hexo-config('motion.transition.sidebar')) &#123; opacity: 0; &#125; &amp;.affix &#123; position: fixed; top: $sidebar-offset; &#125; 其他Next主题请参考修改。 代码Copy功能参考 HEXO优化之（二）—-添加复制功能 功能添加出现Clipboard is not defined错误，需要修改一下Clipboard的源码，123var Clipboard = fuction()&#123;....&#125;;//在Clipboard定义后面增加$.Clipboard = Clipboard;//这是我增加的代码 使用时代码1234567891011121314var clipboard = new $.Clipboard('.btn', &#123; text: function() &#123; //var ue = UM.getEditor('txtContent',&#123;&#125;); //ue.queryCommandValue( 'insertcode' ); return $("#"+domId).val(); &#125;&#125;);clipboard.on('success', function(e) &#123; //console.log(e); e.clearSelection();&#125;);clipboard.on('error', function(e) &#123; //console.log(e);&#125;); 代码折叠主要参考 Hexo Next博客添加折叠块功能添加折叠代码块 Gitalk集成中比较容易出错的地方主要参考 Hexo NexT主题中集成gitalk评论系统基本可以顺利集成下来，但是有几个概念笔者并没有阐述清楚： Homepage URL 和 Authorization callback URL的设置问题这两个值对应的是站点地址，也就是对外的访问网址，比如 https://jingtao910429.github.io,如果绑定了域名信息，则是个人域名，比如 https://jingtaotao.top 主目录配置中的repo设置repo 对应的是GitHub上的repo地址，比如 jingtao910429.github.io]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Hexo+Next</tag>
      </tags>
  </entry>
</search>

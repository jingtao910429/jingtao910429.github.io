<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<script>
    (function(){
        if('tsj3678368'){
            if (prompt('请输入文章密码') !== 'tsj3678368'){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>


  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-circle.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />





  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "d50f4633"
    });
  daovoice('update');
  </script>














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/head.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/head.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/head.png?v=5.1.4">


  <link rel="mask-icon" href="/images/head.png?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/rss2.xml" title="倔强的小码农" type="application/atom+xml" />






<meta name="description" content="1.KVO实现原理KVO基本原理 1.KVO是基于runtime机制实现的 2.当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的通知机制 3.如果原类为Person，那么生成的派生类名为NSKVONotifying_Person 4.每个类对象中都有一个isa指针指">
<meta name="keywords" content="iOS,Android,小程序,js,Python,English,开发者,程序猿,极客,编程,代码,开源,Developer,Programmer,Coder,html,css">
<meta property="og:type" content="article">
<meta property="og:title" content="面试相关题目">
<meta property="og:url" content="http://jingtaotao.top/2018/11/17/面试相关题目/index.html">
<meta property="og:site_name" content="倔强的小码农">
<meta property="og:description" content="1.KVO实现原理KVO基本原理 1.KVO是基于runtime机制实现的 2.当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的通知机制 3.如果原类为Person，那么生成的派生类名为NSKVONotifying_Person 4.每个类对象中都有一个isa指针指">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/1829339-77757288cc139f44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1448717-f1923f87d53bd277.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1448717-c23167e42658955d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-11-25T08:51:24.251Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试相关题目">
<meta name="twitter:description" content="1.KVO实现原理KVO基本原理 1.KVO是基于runtime机制实现的 2.当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的通知机制 3.如果原类为Person，那么生成的派生类名为NSKVONotifying_Person 4.每个类对象中都有一个isa指针指">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/1829339-77757288cc139f44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://jingtaotao.top/2018/11/17/面试相关题目/"/>





<link href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" rel="stylesheet">

  <title>面试相关题目 | 倔强的小码农</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <a href="https://github.com/jingtao910429" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">倔强的小码农</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">专注移动端开发</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-留言板">
          <a href="/guestbook" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-newspaper-o"></i> <br />
            
            留言板
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jingtaotao.top/2018/11/17/面试相关题目/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="静涛">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="倔强的小码农">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">面试相关题目</h1>
        

        <div class="post-meta">

          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-17T11:55:45+08:00">
                2018-11-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/11/17/面试相关题目/" class="leancloud_visitors" data-flag-title="面试相关题目">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8.4k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="1-KVO实现原理"><a href="#1-KVO实现原理" class="headerlink" title="1.KVO实现原理"></a>1.KVO实现原理</h2><h3 id="KVO基本原理"><a href="#KVO基本原理" class="headerlink" title="KVO基本原理"></a>KVO基本原理</h3><blockquote>
<p>1.KVO是基于runtime机制实现的</p>
<p>2.当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的通知机制</p>
<p>3.如果原类为Person，那么生成的派生类名为NSKVONotifying_Person</p>
<p>4.每个类对象中都有一个isa指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法</p>
<p>5.键值观察通知依赖于NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey:一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey:会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。</p>
</blockquote>
<h3 id="KVO深入原理："><a href="#KVO深入原理：" class="headerlink" title="KVO深入原理："></a>KVO深入原理：</h3><blockquote>
<p>1.Apple 使用了 isa 混写（isa-swizzling）来实现 KVO 。当观察对象A时，KVO机制动态创建一个新的名为： NSKVONotifying_A的新类，该类继承自对象A的本类，且KVO为NSKVONotifying_A重写观察属性的setter 方法，setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象属性值的更改情况。</p>
<p>2.NSKVONotifying_A类剖析：在这个过程，被观察对象的 isa 指针从指向原来的A类，被KVO机制修改为指向系统新创建的子类 NSKVONotifying_A类，来实现当前类属性值改变的监听；</p>
<p>3.所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对KVO的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为“NSKVONotifying_A”的类()，就会发现系统运行到注册KVO的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为NSKVONotifying_A的中间类，并指向这个中间类了。</p>
<p>4.（isa 指针的作用：每个对象都有isa 指针，指向该对象的类，它告诉 Runtime 系统这个对象的类是什么。所以对象注册为观察者时，isa指针指向新子类，那么这个被观察的对象就神奇地变成新子类的对象（或实例）了。） 因而在该对象上对 setter 的调用就会调用已重写的 setter，从而激活键值通知机制</p>
<p>5.子类setter方法剖析：KVO的键值观察通知依赖于 NSObject 的两个方法:willChangeValueForKey:和 didChangevlueForKey:，在存取数值的前后分别调用2个方法： 被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该 keyPath 的属性值即将变更；当改变发生后， didChangeValueForKey: 被调用，通知系统该 keyPath 的属性值已经变更；之后， observeValueForKey:ofObject:change:context: 也会被调用。且重写观察属性的setter 方法这种继承方式的注入是在运行时而不是编译时实现的。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/1829339-77757288cc139f44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="KVO"></p>
<h2 id="weak实现原理"><a href="#weak实现原理" class="headerlink" title="weak实现原理"></a>weak实现原理</h2><p>Runtime维护了一个weak表，用于存储指向某个对象的所有weak指针。weak表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象的地址）数组。</p>
<p>1、初始化时：runtime会调用<code>objc_initWeak</code>函数，初始化一个新的weak指针指向对象的地址。</p>
<p>2、添加引用时：<code>objc_initWeak</code>函数会调用 <code>objc_storeWeak()</code> 函数， <code>objc_storeWeak()</code> 的作用是更新指针指向，创建对应的弱引用表。</p>
<p>3、释放时，调用<code>clearDeallocating</code>函数。<code>clearDeallocating</code>函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。</p>
<h3 id="追问的问题一："><a href="#追问的问题一：" class="headerlink" title="追问的问题一："></a>追问的问题一：</h3><p>1.实现weak后，为什么对象释放后会自动为nil？</p>
<p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为 0 的时候会 dealloc，假如 weak 指向的对象内存地址是 a ，那么就会以 a 为键， 在这个 weak 表中搜索，找到所有以 a 为键的 weak 对象，从而设置为 nil 。</p>
<h3 id="追问的问题二："><a href="#追问的问题二：" class="headerlink" title="追问的问题二："></a>追问的问题二：</h3><p>2.当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？</p>
<p>1、调用<code>objc_release</code></p>
<p>2、因为对象的引用计数为0，所以执行dealloc</p>
<p>3、在dealloc中，调用了<code>_objc_rootDealloc</code>函数</p>
<p>4、在<code>_objc_rootDealloc</code>中，调用了<code>object_dispose</code>函数</p>
<p>5、调用<code>objc_destructInstance</code></p>
<p>6、最后调用<code>objc_clear_deallocating</code>,详细过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a. 从weak表中获取废弃对象的地址为键值的记录</span><br><span class="line">b. 将包含在记录中的所有附有 weak修饰符变量的地址，赋值为 nil</span><br><span class="line">c. 将weak表中该记录删除</span><br><span class="line">d. 从引用计数表中删除废弃对象的地址为键值的记录</span><br></pre></td></tr></table></figure>
<h2 id="Controller臃肿优化"><a href="#Controller臃肿优化" class="headerlink" title="Controller臃肿优化"></a>Controller臃肿优化</h2><p>1、添加分类。<br>2、抽象功能类，页面及功能抽出。<br>3、MVVM，部分逻辑放在ViewModel中。<br>4、继承，部分公共功能放在基类中。</p>
<h2 id="UBT"><a href="#UBT" class="headerlink" title="UBT"></a>UBT</h2><p>SDK 整体上主要包含 4 个部分：AOP、Event Collector、Event Cache、Event Upload。</p>
<p>SDK 中的这 4 个模块各自的主要功能如下：</p>
<ul>
<li>AOP：提供数据收集所需要的时机，即通过 Method Swizzling 来 hook 相应类的方法，然后以 Post Notification 的方式提供出去。</li>
<li>Event Collector：监听通知，针对当前事件执行相应的数据收集，并将收集的事件数据提交给缓存模块。</li>
<li>Event Cache：负责事件数据的缓存、序列化以及读取操作，其中包括内存缓存与磁盘缓存。</li>
<li>Event Upload：基于一定的上报策略执行对已收集的事件数据的上报。</li>
</ul>
<h2 id="id和NSObject＊的区别"><a href="#id和NSObject＊的区别" class="headerlink" title="id和NSObject＊的区别"></a>id和NSObject＊的区别</h2><p>id是一个 objc_object 结构体指针，定义是</p>
<p><code>typedef struct objc_object *id</code></p>
<p>id可以理解为指向对象的指针。所有oc的对象 id都可以指向，编译器不会做类型检查，id调用任何存在的方法都不会在编译阶段报错，当然如果这个id指向的对象没有这个方法，该崩溃还是会崩溃的。</p>
<p>NSObject *指向的必须是NSObject的子类，调用的也只能是NSObject里面的方法否则就要做强制类型转换。</p>
<p>不是所有的OC对象都是NSObject的子类，还有一些继承自NSProxy。NSObject *可指向的类型是id的子集。</p>
<h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p>管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。</p>
<p>申请大小：</p>
<p>栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</p>
<p>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p>
<p>碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出</p>
<p>分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</p>
<p>分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的。</p>
<h2 id="高效的实现控件的圆角效果"><a href="#高效的实现控件的圆角效果" class="headerlink" title="高效的实现控件的圆角效果"></a>高效的实现控件的圆角效果</h2><p>1、直接系统方法，<code>cornerRadius</code> 和 <code>maskToBounds</code>，这种方法比较简单，代码量较少，但是操作layer肯定会影响性能，会造成离屏渲染。离屏渲染是指：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">离屏渲染，指的是 GPU 或 CPU 在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。过程中需要切换 contexts (上下文环境),先从当前屏幕切换到离屏的contexts，渲染结束后，又要将 contexts 切换回来，而切换过程十分耗费性能。</span><br></pre></td></tr></table></figure></p>
<p>2、设计切一张圆角且阴影的图片，使用<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resizableImage(withCapInsets: <span class="type">UIEdgeInsets</span>(top: <span class="number">10</span>, <span class="keyword">left</span>: <span class="number">10</span>, bottom: <span class="number">10</span>, <span class="keyword">right</span>: <span class="number">10</span>), resizingMode: .stretch)</span><br></pre></td></tr></table></figure></p>
<p>四周不拉伸，拉伸内容<br>3、使用CAShapeLayer和UIBezierPath来设置圆角，消耗内存较小，渲染较快，缺点：操作了layer，对性能有影响，有离屏渲染。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)setLayerAndBezierPathCutCircularWithView:(<span class="type">UIView</span> *) view</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建BezierPath 并设置角 和 半径 这里只设置了 左上 和 右上</span></span><br><span class="line">    <span class="type">UIBezierPath</span> *path = [<span class="type">UIBezierPath</span> bezierPathWithRoundedRect:view.bounds byRoundingCorners:<span class="type">UIRectCornerTopLeft</span> | <span class="type">UIRectCornerTopRight</span> cornerRadii:<span class="type">CGSizeMake</span>(<span class="number">10</span>, <span class="number">10</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="type">CAShapeLayer</span> *layer = [[<span class="type">CAShapeLayer</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    layer.frame = view.bounds;</span><br><span class="line">    layer.path = path.<span class="type">CGPath</span>;</span><br><span class="line">    view.layer.mask = layer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4、使用Core Graphics框架 和 UIBezierPath 画出一个圆角</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)setGraphicsCutCirculayWithView:(<span class="type">UIImageView</span> *) view</span><br><span class="line">&#123;       </span><br><span class="line">                                 <span class="type">UIGraphicsBeginImageContextWithOptions</span>(view.bounds.size, <span class="type">NO</span>, <span class="number">1.0</span>);</span><br><span class="line">    [[<span class="type">UIBezierPath</span> bezierPathWithRoundedRect:view.bounds cornerRadius:<span class="number">5</span>] addClip];</span><br><span class="line">    [view drawRect:view.bounds];</span><br><span class="line">    view.image = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="comment">// 结束</span></span><br><span class="line">    <span class="type">UIGraphicsEndImageContext</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><p>//单层结论并不准确。</p>
<p>浅复制，单层深复制，完全复制(每一层都深复制) 。</p>
<p>浅复制也就是所说的指针复制，并没有进行对象复制; </p>
<p>单层深复制，也就是我们经常说的深复制，我这里说的单层深复制是对于集合类所说的(即NSArray,NSDictionary,NSSet)，单层深复制指的是只复制了该集合类的最外层，里边的元素没有复制，(即这两个集合类的地址不一样，但是两个集合里所存储的元素的地址是一样的); </p>
<p>完全复制，指的是完全复制整个集合类，也就是说两个集合地址不一样，里边所存储的元素地址也不一样;</p>
<h3 id="非集合类（NSString，NSNumber）"><a href="#非集合类（NSString，NSNumber）" class="headerlink" title="非集合类（NSString，NSNumber）"></a>非集合类（NSString，NSNumber）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[immutableObject copy]  //浅复制  </span><br><span class="line">[immutableObject mutableCopy] //深复制</span><br><span class="line">[mutableObject copy] //深复制</span><br><span class="line">[mutableObject mutableCopy] //深复制</span><br></pre></td></tr></table></figure>
<p>结论：不可变进行copy是浅复制，mutableCopy是深复制，可变的copy，mutableCopy都是深复制。</p>
<h3 id="集合类（NSArray，NSDictionary-NSSet"><a href="#集合类（NSArray，NSDictionary-NSSet" class="headerlink" title="集合类（NSArray，NSDictionary, NSSet)"></a>集合类（NSArray，NSDictionary, NSSet)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[immutableObject copy]  //浅复制</span><br><span class="line">[immutableObject mutableCopy] //单层深复制</span><br><span class="line">[mutableObject copy] //单层深复制</span><br><span class="line">[mutableObject mutableCopy] //单层深复制</span><br></pre></td></tr></table></figure>
<p>结论：不可变进行copy是浅复制，mutableCopy是单层深复制，可变的copy，mutableCopy都是单层深复制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *copyArray = [[NSArray alloc] initWithArray:array copyItems:YES];  // 完全复制</span><br></pre></td></tr></table></figure></p>
<p>以上我们所说的两种情况默认都实现了NSCopying和NSMutableCopying协议<br>对于自定义继承自NSObject的类</p>
<p>copy需要实现NSCopying协议，然后实现以下方法，否则copy会crash</p>
<p>需要特别注意，可变数组或字典的copy与mutableCopy的区别，<a href="https://blog.csdn.net/Mazy_ma/article/details/51899397" target="_blank" rel="noopener">https://blog.csdn.net/Mazy_ma/article/details/51899397</a></p>
<h2 id="Struct与Class"><a href="#Struct与Class" class="headerlink" title="Struct与Class"></a>Struct与Class</h2><p>Swift 中类和结构体非常类似，都具有定义和使用属性、方法、下标和构造器等面向对象特性，但是结构体不具有继承性，也不具备运行时强制类型转换、使用析构器和使用引用计等能力。</p>
<p>Swift 中 struct 是值类型，而 class 是引用类型，所以这篇文章 struct 的行为也可以用到所有的值类型上面，相同地 class 的行为也可以用到引用类型上。</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>   1、安全性：</p>
<p><code>因为 Struct 是用值类型传递的，它们没有引用计数。</code></p>
<p>   2、内存：</p>
<p><code>由于他们没有引用数，他们不会因为循环引用导致内存泄漏。</code><br>   3、速度:</p>
<p> <code>值类型通常来说是以栈的形式分配的，而不是用堆。因此他们比 Class 要快很多!  (http://stackoverflow.com/a/24243626/596821)</code><br>   4、拷贝：</p>
<p> <code>Objective-C 里拷贝一个对象,你必须选用正确的拷贝类型（深拷贝、浅拷贝）,而值类型的拷贝则非常轻松！</code><br>   5、线程安全</p>
<p><code>值类型是自动线程安全的。无论你从哪个线程去访问你的 Struct ，都非常简单。</code></p>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>   1、Objective-C</p>
<p><code>当你的项目的代码是 Swift 和 Objective-C 混合开发时，你会发现在 Objective-C 的代码里无法调用 Swift 的 Struct。因为要在 Objective-C 里调用 Swift 代码的话，对象需要继承于 NSObject。
Struct 不是 Objective-C 的好朋友。</code></p>
<p>   2、继承</p>
<p><code>Struct 不能相互继承。</code></p>
<p>   3、NSUserDefaults</p>
<p><code>Struct 不能被序列化成 NSData 对象。</code></p>
<h3 id="知识延伸：为什么访问struct比class快？"><a href="#知识延伸：为什么访问struct比class快？" class="headerlink" title="知识延伸：为什么访问struct比class快？"></a>知识延伸：为什么访问struct比class快？</h3><p>“堆”和“栈”并不是数据结构上的Heap跟Stack，而是程序运行中的不同内存空间。栈是程序启动的时候，系统事先分配的，使用过程中，系统不干预；堆是用的时候才向系统申请的，用完了需要交还，这个申请和交还的过程开销相对就比较大了。</p>
<p>栈是编译时分配空间，而堆是动态分配（运行时分配空间），所以栈的速度快。</p>
<p>从两方面来考虑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.分配和释放：堆在分配和释放时都要调用函数（MALLOC,FREE)，比如分配时会到堆空间去寻找足够大小的空间（因为多次分配释放后会造成空洞），这些都会花费一定的时间，而栈却不需要这些。</span><br><span class="line"></span><br><span class="line">2.访问时间：访问堆的一个具体单元，需要两次访问内存，第一次得取得指针，第二次才是真正得数据，而栈只需访问一次。</span><br></pre></td></tr></table></figure>
<h2 id="响应链及RunLoop"><a href="#响应链及RunLoop" class="headerlink" title="响应链及RunLoop"></a>响应链及RunLoop</h2><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p>将UIResponder作为父类派生出如下子类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-UIResponder            </span><br><span class="line">	</span><br><span class="line">　　-UIApplication</span><br><span class="line">	</span><br><span class="line">　　-UIView</span><br><span class="line">	</span><br><span class="line">　　　　-UIControl</span><br><span class="line">	</span><br><span class="line">　　-UIViewController</span><br></pre></td></tr></table></figure>
<p> 1.我们可以看到所有的UIView都继承自UIResponder，这也很容易理解，因为一般的UIView都将在界面上呈现，对于触摸事件都会非常敏感。</p>
<p> 2.而UIControl类则是UIButton等控件的父类，系统帮助我们将此类控件的共有操作都封装在UIControl中。</p>
<p> 3.对于UIApplication和UIViewController不像UIView那样可被触摸，但是不要忘记了UIResponder除了可以处理触摸事件外还可以进行其他事件的处理，而这些事件会被响应者链机制传递到 UIApplication和UIViewController。</p>
<p>UIResponder 是 UIView 的父类。responder 能够处理触摸、手势、远程控制等事件。之所以它是一个单独的类而没有合并到 UIView 中，是因为 UIResponder 有更多的子类，最明显的就是 UIApplication 和 UIViewController。</p>
<p>UIView 子类处理所有跟内容绘制有关的事情以及触摸时间。<br>UIControl 建立在视图上，增加了更多的交互支持。最重要的是，它增加了 target / action 模式。UIView通过delegate交互。</p>
<h3 id="响应链大概有以下几个步骤："><a href="#响应链大概有以下几个步骤：" class="headerlink" title="响应链大概有以下几个步骤："></a>响应链大概有以下几个步骤：</h3><blockquote>
<p>设备将touch到的UITouch和UIEvent对象打包, 放到当前活动的Application的事件队列中</p>
</blockquote>
<blockquote>
<p>单例的UIApplication会从事件队列中取出触摸事件并传递给单例UIWindow</p>
</blockquote>
<blockquote>
<p>UIWindow使用hitTest:withEvent:方法查找touch操作的所在的视图view</p>
</blockquote>
<h3 id="RunLoop-的作用"><a href="#RunLoop-的作用" class="headerlink" title="RunLoop 的作用"></a>RunLoop 的作用</h3><p>1.保证程序不退出保活线程，它就是一个死循环：”接受事件 -&gt; …等待 -&gt; 处理”</p>
<p>2.负责监听管理事件，触摸事件（用户交互事件）、时钟事件（Timer）、网络事件（网络请求回调接收等）以及系统事件内核事件；</p>
<p>3.如果没有事件则进入睡眠状态</p>
<h3 id="CFRunLoopMode的类型"><a href="#CFRunLoopMode的类型" class="headerlink" title="CFRunLoopMode的类型"></a>CFRunLoopMode的类型</h3><blockquote>
<ol>
<li>kCFRunLoopDefaultMode<br><code>App的默认Mode，通常主线程是在这个Mode下运行</code></li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>UITrackingRunLoopMode：<br><code>界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</code></li>
<li>UIInitializationRunLoopMode:<br><code>在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用</code></li>
<li>GSEventReceiveRunLoopMode:<br><code>接受系统事件的内部 Mode，通常用不到</code></li>
<li>kCFRunLoopCommonModes:<br><code>这是一个占位用的Mode，作为标记kCFRunLoopDefaultMode和UITrackingRunLoopMode用，并不是一种真正的Mode</code></li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RunLoop这边我大概讲一下：</span><br><span class="line">	</span><br><span class="line">主线程的RunLoop被唤醒</span><br><span class="line">	</span><br><span class="line">通知Observer，处理Timer和Source 0</span><br><span class="line">	</span><br><span class="line">Springboard接受touch event之后转给App进程</span><br><span class="line">	</span><br><span class="line">RunLoop处理Source 1，Source1 就会触发回调，并调用_UIApplicationHandleEventQueue() 进行应用内部的分发。</span><br><span class="line">	</span><br><span class="line">RunLoop处理完毕进入睡眠，此前会释放旧的autorelease pool并新建一个autorelease pool</span><br></pre></td></tr></table></figure>
<h2 id="NStimer准吗？谈谈你的看法？如果不准该怎样实现一个精确的NSTimer"><a href="#NStimer准吗？谈谈你的看法？如果不准该怎样实现一个精确的NSTimer" class="headerlink" title=".NStimer准吗？谈谈你的看法？如果不准该怎样实现一个精确的NSTimer?"></a>.NStimer准吗？谈谈你的看法？如果不准该怎样实现一个精确的NSTimer?</h2><p>1.不准</p>
<p>2.不准的原因如下：</p>
<p>1、NSTimer加在main runloop中，模式是NSDefaultRunLoopMode，main负责所有主线程事件，例如UI界面的操作，复杂的运算，这样在同一个runloop中timer就会产生阻塞。</p>
<p>2、模式的改变。主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。</p>
<p>当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个ScrollView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。所以就会影响到NSTimer不准的情况。</p>
<p>PS:DefaultMode 是 App 平时所处的状态，rackingRunLoopMode 是追踪 ScrollView 滑动时的状态。</p>
<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>1、在主线程中进行NSTimer操作，但是将NSTimer实例加到main runloop的特定mode（模式）中。避免被复杂运算操作或者UI界面刷新所干扰。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.timer = [<span class="type">NSTimer</span> timerWithTimeInterval:<span class="number">1</span> target:<span class="keyword">self</span> selector:@selector(showTime) userInfo:<span class="literal">nil</span> repeats:<span class="type">YES</span>];</span><br><span class="line"></span><br><span class="line">[[<span class="type">NSRunLoop</span> currentRunLoop] addTimer:<span class="keyword">self</span>.timer forMode:<span class="type">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure></p>
<p>2、在子线程中进行NSTimer的操作，再在主线程中修改UI界面显示操作结果；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (void)timerMethod2 &#123;</span><br><span class="line"></span><br><span class="line">NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];</span><br><span class="line"></span><br><span class="line">[thread start];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)newThread</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">@autoreleasepool</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">[NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(showTime) userInfo:nil repeats:YES];</span><br><span class="line"></span><br><span class="line">[[NSRunLoop currentRunLoop] run];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line"></span><br><span class="line">一开始的时候系统就为我们将主线程的main runloop隐式的启动了。</span><br><span class="line"></span><br><span class="line">在创建线程的时候，可以主动获取当前线程的runloop。每个子线程对应一个runloop</span><br></pre></td></tr></table></figure></p>
<h3 id="方法二：直接使用GCD替代！GCD创建的定时器不受RunLoop中Modes影响"><a href="#方法二：直接使用GCD替代！GCD创建的定时器不受RunLoop中Modes影响" class="headerlink" title="方法二：直接使用GCD替代！GCD创建的定时器不受RunLoop中Modes影响"></a>方法二：直接使用GCD替代！GCD创建的定时器不受RunLoop中Modes影响</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义需要计时的时间</span></span><br><span class="line"><span class="keyword">var</span> timeCount = <span class="number">60</span></span><br><span class="line"><span class="comment">// 在global线程里创建一个时间源</span></span><br><span class="line"><span class="keyword">let</span> codeTimer = <span class="type">DispatchSource</span>.makeTimerSource(queue:      <span class="type">DispatchQueue</span>.global())</span><br><span class="line"><span class="comment">// 设定这个时间源是每秒循环一次，立即开始</span></span><br><span class="line">codeTimer.schedule(deadline: .now(), repeating: .seconds(<span class="number">1</span>))</span><br><span class="line"><span class="comment">// 设定时间源的触发事件</span></span><br><span class="line">codeTimer.setEventHandler(handler: &#123;</span><br><span class="line">    <span class="comment">// 每秒计时一次</span></span><br><span class="line">    timeCount = timeCount - <span class="number">1</span></span><br><span class="line">    <span class="comment">// 时间到了取消时间源</span></span><br><span class="line">    <span class="keyword">if</span> timeCount &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        codeTimer.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回主线程处理一些事件，更新UI等等</span></span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 启动时间源</span></span><br><span class="line">codeTimer.resume()</span><br></pre></td></tr></table></figure>
<h2 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h2><p>1).代码区：存放函数二进制代码</p>
<p>2).数据区：系统运行时申请内存并初始化，系统退出时由系统释放。存放全局变量、静态变量、常量</p>
<p>3).堆区：通过malloc等函数或new等操作符动态申请得到，需程序员手动申请和释放</p>
<p>4).栈区：函数模块内申请，函数结束时由系统自动释放。存放局部变量、函数参数</p>
<h2 id="block和函数指针的理解"><a href="#block和函数指针的理解" class="headerlink" title="block和函数指针的理解"></a>block和函数指针的理解</h2><p>相似点：</p>
<p>函数指针和Block都可以实现回调的操作，声明上也很相似，实现上都可以看成是一个代码片段。</p>
<p>函数指针类型和Block类型都可以作为变量和函数参数的类型。（typedef定义别名之后，这个别名就是一个类型）</p>
<p>不同点：</p>
<p>函数指针只能指向预先定义好的函数代码块（可以是其他文件里面定义，通过函数参数动态传入的），函数地址是在编译链接时就已经确定好的。</p>
<p>Block本质是Objective-C对象，是NSObject的子类，可以接收消息。</p>
<p>函数里面只能访问全局变量，而Block代码块不光能访问全局变量，还拥有当前栈内存和堆内存变量的可读性（当然通过__block访问指示符修饰的局部变量还可以在block代码块里面进行修改）。</p>
<p>从内存的角度看，函数指针只不过是指向代码区的一段可执行代码，而block实际上是程序运行过程中在栈内存动态创建的对象，可以向其发送copy消息将block对象拷贝到堆内存，以延长其生命周期。</p>
<h2 id="对象内存结构中的-isa-指针是用来做什么的？"><a href="#对象内存结构中的-isa-指针是用来做什么的？" class="headerlink" title="对象内存结构中的 isa 指针是用来做什么的？"></a>对象内存结构中的 isa 指针是用来做什么的？</h2><p>问题:Objective-C 对象内存结构中的 isa 指针是用来做什么的，有什么用？<br>答案:Objective-C 是一门面向对象的编程语言。每一个对象都是一个类的实例。在 Objective-C 语言的内部，每一个对象都有一个名为 isa 的指针，指向该对象的类。每一个类描述了一系列它的实例的特点，包括成员变量的列表，成员函数的列表等。每一个对象都可以接受消息，而对象能够接收的消息列表是保存在它所对应的类中。</p>
<p>在 Xcode 中按Shift + Command + O, 然后输入 NSObject.h 和 objc.h，可以打开 NSObject 的定义头文件，通过头文件我们可以看到，NSObject 就是一个包含 isa 指针的结构体，如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1448717-f1923f87d53bd277.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="isa结构体"></p>
<p>按照面向对象语言的设计原则，所有事物都应该是对象（严格来说 Objective-C 并没有完全做到这一点，因为它有象 int, double 这样的简单变量类型，而 Swift 语言，连 int 变量也是对象）。在 Objective-C 语言中，每一个类实际上也是一个对象。每一个类也有一个名为 isa 的指针。每一个类也可以接受消息，例如代码[NSObject alloc]，就是向 NSObject 这个类发送名为alloc消息。</p>
<p>在 Xcode 中按Shift + Command + O, 然后输入 runtime.h，可以打开 Class 的定义头文件，通过头文件我们可以看到，Class 也是一个包含 isa 指针的结构体，如下图所示。（图中除了 isa 外还有其它成员变量，但那是为了兼容非 2.0 版的 Objective-C 的遗留逻辑，大家可以忽略它。）</p>
<p>因为类也是一个对象，那它也必须是另一个类的实列，这个类就是元类 (metaclass)。元类保存了类方法的列表。当一个类方法被调用时，元类会首先查找它本身是否有该类方法的实现，如果没有，则该元类会向它的父类查找该方法，直到一直找到继承链的头。</p>
<p>元类 (metaclass) 也是一个对象，那么元类的 isa 指针又指向哪里呢？为了设计上的完整，所有的元类的 isa 指针都会指向一个根元类 (root metaclass)。根元类 (root metaclass) 本身的 isa 指针指向自己，这样就行成了一个闭环。上面提到，一个对象能够接收的消息列表是保存在它所对应的类中的。在实际编程中，我们几乎不会遇到向元类发消息的情况，那它的 isa 指针在实际上很少用到。不过这么设计保证了面向对象概念在 Objective-C 语言中的完整，即语言中的所有事物都是对象，都有 isa 指针。</p>
<p>我们再来看看继承关系，由于类方法的定义是保存在元类 (metaclass) 中，而方法调用的规则是，如果该类没有一个方法的实现，则向它的父类继续查找。所以，为了保证父类的类方法可以在子类中可以被调用，所以子类的元类会继承父类的元类，换而言之，类对象和元类对象有着同样的继承关系。</p>
<p>我很想把关系说清楚一些，但是这块儿确实有点绕，我们还是来看图吧，很多时候图象比文字表达起来更为直观。下面这张图或许能够让大家对 isa 和继承的关系清楚一些：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1448717-c23167e42658955d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="isa继承"></p>
<p>我们可以从图中看出：</p>
<p>NSObject 的类中定义了实例方法，例如 -(id)init 方法 和 - (void)dealloc 方法。<br>NSObject 的元类中定义了类方法，例如 +(id)alloc 方法 和 + (void)load 、+ (void)initialize 方法。<br>NSObject 的元类继承自 NSObject 类，所以 NSObject 类是所有类的根，因此 NSObject 中定义的实例方法可以被所有对象调用，例如 - (id)init 方法 和 - (void)dealloc 方法。<br>NSObject 的元类的 isa 指向自己。<br>isa swizzling 的应用</p>
<p>系统提供的 KVO 的实现，就利用了动态地修改 isa 指针的值的技术。在 苹果的文档<br>中可以看到如下描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Key-Value Observing Implementation Details</span><br><span class="line">Automatic key-value observing is implemented using a technique called isa-swizzling.</span><br><span class="line">The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</span><br><span class="line">When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</span><br><span class="line">You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</span><br></pre></td></tr></table></figure>
<h2 id="iOS-Runtime详解"><a href="#iOS-Runtime详解" class="headerlink" title="iOS Runtime详解"></a>iOS Runtime详解</h2><p><a href="https://www.jianshu.com/p/6ebda3cd8052" target="_blank" rel="noopener">https://www.jianshu.com/p/6ebda3cd8052</a></p>
<h2 id="NSCache"><a href="#NSCache" class="headerlink" title="NSCache"></a>NSCache</h2><p>SD图片缓存就用的该类 一个可变集合，用于临时存储临时键值对，在资源不足的情况下被释放。<br>NSCache类包含了各种自动释放内存的机制，可以确保缓存不会占用太多的系统内存。如果其他应用程序需要内存，这些机制会从缓存中删除一些项目，从而最大限度地减少其内存占用。<br>您可以从不同的线程中添加，删除和查询缓存中的项目，而无需自己锁定缓存。<br>与NSMutableDictionary对象不同，缓存不会复制放入其中的关键对象。<br>您通常使用NSCache对象临时存储对象与创建重要的临时数据。重用这些对象可以提供性能优势，因为它们的值不必重新计算。但是，这些对象对应用程序并不重要，如果内存不足，可以将其释放。如果释放，则需要时重新计算它们的值。<br>具有可以在不使用时释放的子组件的对象可以采用NSDiscardableContent协议来改善缓存机制的行为。默认情况下，如果缓存中的NSDiscardableContent对象的内容被释放，它们将被自动删除，尽管这个自动删除机制是可以改变的。如果一个NSDiscardableContent对象被放入缓存中，缓存在移除时调用discardContentIfPossible。</p>
<h2 id="如果项目开始容错处理没做？如何防止拦截潜在的崩溃？"><a href="#如果项目开始容错处理没做？如何防止拦截潜在的崩溃？" class="headerlink" title="如果项目开始容错处理没做？如何防止拦截潜在的崩溃？"></a>如果项目开始容错处理没做？如何防止拦截潜在的崩溃？</h2><p>例：</p>
<p>1、category给类添加方法用来替换掉原本存在潜在崩溃的方法。</p>
<p>2、利用runtime方法交换技术，将系统方法替换成类添加的新方法。</p>
<p>3、利用异常的捕获来防止程序的崩溃，并且进行相应的处理。</p>
<p>总结：</p>
<p>1、不要过分相信服务器返回的数据会永远的正确。</p>
<p>2、在对数据处理上，要进行容错处理，进行相应判断之后再处理数据，这是一个良好的编程习惯。</p>
<h2 id="内存泄漏的几种情况"><a href="#内存泄漏的几种情况" class="headerlink" title="内存泄漏的几种情况"></a>内存泄漏的几种情况</h2><p>答：循环引用：delegate，block，timer等</p>
<p>图片没释放，instrument调试后，发现没被释放的全是imageIO，差不多就知道了，把读图的方式，从[UIImage imageNamed:@””],改成imageWithContentsOfFile，就可以了。</p>
<p>CoreFoundation对象(C对象) : 只要函数中包含了create\new\copy\retain等关键字, 那么这些方法产生的对象, 就必须在不再使用的时候调用1次CFRelease或者其他release函数</p>
<p>地图，蓝牙等框架的使用，在根据文档实现某地图，蓝牙相关功能的同时，我们需要注意内存的正确释放，大体需要注意的有需在使用完毕时将地图、代理等滞空为nil，注意地图中标注（大头针）的复用，保存蓝牙设备的数据源清空，使用完毕时清空标注数组等。</p>
<p>大数量的循环，该循环内产生大量的临时对象，直至循环结束才释放，可能导致内存泄漏，解决方法为在循环中创建自己的autoReleasePool，及时释放占用内存大的临时变量，减少内存占用峰值。</p>
<h2 id="主线程死锁"><a href="#主线程死锁" class="headerlink" title="主线程死锁"></a>主线程死锁</h2><h2 id="同步、异步-与-串行、并行的区别"><a href="#同步、异步-与-串行、并行的区别" class="headerlink" title="同步、异步 与 串行、并行的区别"></a>同步、异步 与 串行、并行的区别</h2><p>同步、异步：</p>
<p>指的是能否开启新的线程。同步不能开启新的线程，异步可以。</p>
<p>串行、并行：</p>
<p>指的是任务的执行方式。串行是指多个任务时，各个任务按顺序执行，完成一个之后才能进行下一个。并行指的是多个任务可以同时执行。异步是多个任务并行的前提条件。</p>
<p>并发和并行:</p>
<p>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。</p>
<h2 id="GCD-和-NSOperation-进行比较"><a href="#GCD-和-NSOperation-进行比较" class="headerlink" title="GCD 和 NSOperation 进行比较"></a>GCD 和 NSOperation 进行比较</h2><p>(1).NSOperation 是对 GCD 的封装，面相对象的类，GCD 只是一组方法 API。</p>
<p>(2).NSOperation 可以实现一些 GCD 中实现不了，或者实现比较复杂的功能。比如：设置最大并发数，设置线程间的依赖关系。</p>
<p>(3).实现某个多线程功能，使用 GCD，简单易用。实现某个多线程模块，使用 NSOperation，方便类的管理。</p>
<h2 id="strong和copy的区别"><a href="#strong和copy的区别" class="headerlink" title="strong和copy的区别"></a>strong和copy的区别</h2><p>代码示例</p>
<p>还是结合代码来说明这个情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">@property (strong, nonatomic) NSArray *bookArray1;</span><br><span class="line">@property (copy, nonatomic) NSArray *bookArray2;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">//省略setter方法</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//Person调用</span><br><span class="line">main()&#123;</span><br><span class="line">    NSMutableArray *books = [@[@&quot;book1&quot;] mutableCopy];</span><br><span class="line">    Person *person = [[Person alloc] init];</span><br><span class="line">    person.bookArray1 = books;</span><br><span class="line">    person.bookArray2 = books;</span><br><span class="line">    [books addObject:@&quot;book2&quot;];</span><br><span class="line">    NSLog(@&quot;bookArray1:%@&quot;,person.bookArray1);</span><br><span class="line">    NSLog(@&quot;bookArray2:%@&quot;,person.bookArray2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，使用strong修饰的person.bookArray1输出是[book1,book2]，而使用copy修饰的person.bookArray2输出是[book1]。这下可以看出来区别了吧。</p>
<p>备注：使用strong，则person.bookArray1与可变数组books指向同一块内存区域，books内容改变，导致person.bookArray1的内容改变，因为两者是同一个东西；而使用copy，person.bookArray2在赋值之前，将books内容复制，创建一个新的内存区域，所以两者不是一回事，books的改变不会导致person.bookArray2的改变。<br>说到底，其实就是不同的修饰符，对应不同的setter方法，</p>
<ol>
<li>strong对应的setter方法，是将_property先release（_property release），然后将参数retain（property retain），最后是_property = property。</li>
<li>copy对应的setter方法，是将_property先release（_property release），然后拷贝参数内容（property copy），创建一块新的内存地址，最后_property = property。</li>
</ol>
<p>retain是指针拷贝，copy是内容拷贝。在拷贝之前，都会释放旧的对象。</p>
<p><a href="https://blog.csdn.net/haha_hello/article/details/67106284" target="_blank" rel="noopener">https://blog.csdn.net/haha_hello/article/details/67106284</a></p>
<h2 id="NSSet"><a href="#NSSet" class="headerlink" title="NSSet"></a>NSSet</h2><p><a href="https://www.douban.com/note/609880170/" target="_blank" rel="noopener">https://www.douban.com/note/609880170/</a><br><a href="https://www.jianshu.com/p/915356e280fc" target="_blank" rel="noopener">https://www.jianshu.com/p/915356e280fc</a></p>
<h2 id="block的修饰词为什么选用copy"><a href="#block的修饰词为什么选用copy" class="headerlink" title="block的修饰词为什么选用copy"></a>block的修饰词为什么选用copy</h2><p><a href="https://www.cnblogs.com/jingxin1992/p/7145596.html" target="_blank" rel="noopener">https://www.cnblogs.com/jingxin1992/p/7145596.html</a></p>
<h2 id="修改readonly属性的值"><a href="#修改readonly属性的值" class="headerlink" title="修改readonly属性的值"></a>修改readonly属性的值</h2><p>kvc来设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[stu setValue:@&quot;胡说&quot; forKey:NSStringFromSelector(@selector(hisName))];</span><br></pre></td></tr></table></figure></p>
<p>若想禁止kvc修改readonly属性的值，则可以在定义readonly属性的类中添加该方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//默认返回为YES，表示可允许修改。改为NO即可</span><br><span class="line">+(BOOL)accessInstanceVariablesDirectly&#123;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结:</p>
<p>当我们声明一个 readonly 的属性，外部可能会通过 KVC 修改该属性值。<br>为了避免 KVC 修改属性值，须将定义属性所在类的类方法 + (BOOL)accessInstanceVariablesDirectly 重写，使其返回 NO.</p>
<h2 id="TCP三次握手和四次挥手"><a href="#TCP三次握手和四次挥手" class="headerlink" title="TCP三次握手和四次挥手"></a>TCP三次握手和四次挥手</h2><p><a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">https://blog.csdn.net/qzcsu/article/details/72861891</a></p>
<h2 id="Swift相关"><a href="#Swift相关" class="headerlink" title="Swift相关"></a>Swift相关</h2><h2 id="Optional实质"><a href="#Optional实质" class="headerlink" title="Optional实质"></a>Optional实质</h2><p>Optional Type 的本质是一个枚举类型，拆包其实相当于switch &amp; case<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A type that can represent either a `Wrapped` value or `nil`, the absence</span></span><br><span class="line"><span class="comment">/// of a value.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Optional</span>&lt;<span class="title">Wrapped</span>&gt; : <span class="title">_Reflectable</span>, <span class="title">NilLiteralConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Some</span>(<span class="type">Wrapped</span>)</span><br><span class="line">    <span class="comment">/// Construct a `nil` instance.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>()</span><br><span class="line">    <span class="comment">/// Construct a non-`nil` instance that stores `some`.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> some: <span class="type">Wrapped</span>)</span><br><span class="line">    <span class="comment">/// If `self == nil`, returns `nil`.  Otherwise, returns `f(self!)`.</span></span><br><span class="line">    <span class="meta">@warn_unused_result</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;U&gt;<span class="params">(@noescape f: <span class="params">(Wrapped)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">U</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">U</span>?</span><br><span class="line">    <span class="comment">/// Returns `nil` if `self` is `nil`, `f(self!)` otherwise.</span></span><br><span class="line">    <span class="meta">@warn_unused_result</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;U&gt;<span class="params">(@noescape f: <span class="params">(Wrapped)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">U</span>?) <span class="keyword">rethrows</span> -&gt; <span class="type">U</span>?</span><br><span class="line">    <span class="comment">/// Create an instance initialized with `nil`.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(nilLiteral: ())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Swift-mutating关键字的使用"><a href="#Swift-mutating关键字的使用" class="headerlink" title="Swift - mutating关键字的使用"></a>Swift - mutating关键字的使用</h2><p>Swift中protocol的功能比OC中强大很多，不仅能再class中实现，同时也适用于struct、enum。<br>使用 mutating 关键字修饰方法是为了能在该方法中修改 struct 或是 enum 的变量，在设计接口的时候，也要考虑到使用者程序的扩展性。所以要多考虑使用mutating来修饰方法。</p>
<h2 id="SDWebImage原理和缓存机制"><a href="#SDWebImage原理和缓存机制" class="headerlink" title="SDWebImage原理和缓存机制"></a>SDWebImage原理和缓存机制</h2><p><a href="https://www.jianshu.com/p/7dea5b081d24" target="_blank" rel="noopener">https://www.jianshu.com/p/7dea5b081d24</a><br><a href="https://blog.csdn.net/fucuiping_1314/article/details/79035138" target="_blank" rel="noopener">https://blog.csdn.net/fucuiping_1314/article/details/79035138</a></p>
<h2 id="利用CADisplayLink的与屏幕刷新同步调用的特性"><a href="#利用CADisplayLink的与屏幕刷新同步调用的特性" class="headerlink" title="利用CADisplayLink的与屏幕刷新同步调用的特性"></a>利用CADisplayLink的与屏幕刷新同步调用的特性</h2><h2 id="RunTime详解"><a href="#RunTime详解" class="headerlink" title="RunTime详解"></a>RunTime详解</h2><p><a href="https://www.jianshu.com/p/6ebda3cd8052" target="_blank" rel="noopener">https://www.jianshu.com/p/6ebda3cd8052</a></p>
<h2 id="moduleMap"><a href="#moduleMap" class="headerlink" title="moduleMap"></a>moduleMap</h2><p><a href="https://blog.dianqk.org/2017/05/01/dev-on-pod/" target="_blank" rel="noopener">https://blog.dianqk.org/2017/05/01/dev-on-pod/</a></p>

      
    </div>
    
    
    


  <div>
	
<div style="text-align:center;color: #ccc;font-size:14px;">
	------ 本文结束 <i class="fa fa-paw"></i> 感谢您的阅读 ------</div>

  </div>


    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>小主，赏个呗~</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechat.png" alt="静涛 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.png" alt="静涛 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    静涛
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://jingtaotao.top/2018/11/17/面试相关题目/" title="面试相关题目">http://jingtaotao.top/2018/11/17/面试相关题目/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/10/31/设计模式之结构型模式-适配器模式/" rel="next" title="设计模式之结构型模式-适配器模式">
                <i class="fa fa-chevron-left"></i> 设计模式之结构型模式-适配器模式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

    
  <div id="gitalk-container"></div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/head.png"
                alt="静涛" />
            
              <p class="site-author-name" itemprop="name">静涛</p>
              <p class="site-description motion-element" itemprop="description">Coder</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/rss2.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/jingtao910429" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:wwt_910429@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://github.com/jingtao910429" title="静涛" target="_blank">静涛</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://gitee.com/jingtao910429" title="oschina" target="_blank">oschina</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-KVO实现原理"><span class="nav-number">1.</span> <span class="nav-text">1.KVO实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#KVO基本原理"><span class="nav-number">1.1.</span> <span class="nav-text">KVO基本原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KVO深入原理："><span class="nav-number">1.2.</span> <span class="nav-text">KVO深入原理：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#weak实现原理"><span class="nav-number">2.</span> <span class="nav-text">weak实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#追问的问题一："><span class="nav-number">2.1.</span> <span class="nav-text">追问的问题一：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#追问的问题二："><span class="nav-number">2.2.</span> <span class="nav-text">追问的问题二：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Controller臃肿优化"><span class="nav-number">3.</span> <span class="nav-text">Controller臃肿优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UBT"><span class="nav-number">4.</span> <span class="nav-text">UBT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#id和NSObject＊的区别"><span class="nav-number">5.</span> <span class="nav-text">id和NSObject＊的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆和栈的区别"><span class="nav-number">6.</span> <span class="nav-text">堆和栈的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高效的实现控件的圆角效果"><span class="nav-number">7.</span> <span class="nav-text">高效的实现控件的圆角效果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#copy"><span class="nav-number">8.</span> <span class="nav-text">copy</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#非集合类（NSString，NSNumber）"><span class="nav-number">8.1.</span> <span class="nav-text">非集合类（NSString，NSNumber）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合类（NSArray，NSDictionary-NSSet"><span class="nav-number">8.2.</span> <span class="nav-text">集合类（NSArray，NSDictionary, NSSet)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Struct与Class"><span class="nav-number">9.</span> <span class="nav-text">Struct与Class</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#优点："><span class="nav-number">9.1.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点："><span class="nav-number">9.2.</span> <span class="nav-text">缺点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#知识延伸：为什么访问struct比class快？"><span class="nav-number">9.3.</span> <span class="nav-text">知识延伸：为什么访问struct比class快？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#响应链及RunLoop"><span class="nav-number">10.</span> <span class="nav-text">响应链及RunLoop</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#继承关系"><span class="nav-number">10.1.</span> <span class="nav-text">继承关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#响应链大概有以下几个步骤："><span class="nav-number">10.2.</span> <span class="nav-text">响应链大概有以下几个步骤：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RunLoop-的作用"><span class="nav-number">10.3.</span> <span class="nav-text">RunLoop 的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CFRunLoopMode的类型"><span class="nav-number">10.4.</span> <span class="nav-text">CFRunLoopMode的类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NStimer准吗？谈谈你的看法？如果不准该怎样实现一个精确的NSTimer"><span class="nav-number">11.</span> <span class="nav-text">.NStimer准吗？谈谈你的看法？如果不准该怎样实现一个精确的NSTimer?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一"><span class="nav-number">11.1.</span> <span class="nav-text">方法一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：直接使用GCD替代！GCD创建的定时器不受RunLoop中Modes影响"><span class="nav-number">11.2.</span> <span class="nav-text">方法二：直接使用GCD替代！GCD创建的定时器不受RunLoop中Modes影响</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存分区"><span class="nav-number">12.</span> <span class="nav-text">内存分区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#block和函数指针的理解"><span class="nav-number">13.</span> <span class="nav-text">block和函数指针的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象内存结构中的-isa-指针是用来做什么的？"><span class="nav-number">14.</span> <span class="nav-text">对象内存结构中的 isa 指针是用来做什么的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iOS-Runtime详解"><span class="nav-number">15.</span> <span class="nav-text">iOS Runtime详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSCache"><span class="nav-number">16.</span> <span class="nav-text">NSCache</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如果项目开始容错处理没做？如何防止拦截潜在的崩溃？"><span class="nav-number">17.</span> <span class="nav-text">如果项目开始容错处理没做？如何防止拦截潜在的崩溃？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存泄漏的几种情况"><span class="nav-number">18.</span> <span class="nav-text">内存泄漏的几种情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主线程死锁"><span class="nav-number">19.</span> <span class="nav-text">主线程死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#同步、异步-与-串行、并行的区别"><span class="nav-number">20.</span> <span class="nav-text">同步、异步 与 串行、并行的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GCD-和-NSOperation-进行比较"><span class="nav-number">21.</span> <span class="nav-text">GCD 和 NSOperation 进行比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#strong和copy的区别"><span class="nav-number">22.</span> <span class="nav-text">strong和copy的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSSet"><span class="nav-number">23.</span> <span class="nav-text">NSSet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#block的修饰词为什么选用copy"><span class="nav-number">24.</span> <span class="nav-text">block的修饰词为什么选用copy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#修改readonly属性的值"><span class="nav-number">25.</span> <span class="nav-text">修改readonly属性的值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP三次握手和四次挥手"><span class="nav-number">26.</span> <span class="nav-text">TCP三次握手和四次挥手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Swift相关"><span class="nav-number">27.</span> <span class="nav-text">Swift相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Optional实质"><span class="nav-number">28.</span> <span class="nav-text">Optional实质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Swift-mutating关键字的使用"><span class="nav-number">29.</span> <span class="nav-text">Swift - mutating关键字的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SDWebImage原理和缓存机制"><span class="nav-number">30.</span> <span class="nav-text">SDWebImage原理和缓存机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用CADisplayLink的与屏幕刷新同步调用的特性"><span class="nav-number">31.</span> <span class="nav-text">利用CADisplayLink的与屏幕刷新同步调用的特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunTime详解"><span class="nav-number">32.</span> <span class="nav-text">RunTime详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#moduleMap"><span class="nav-number">33.</span> <span class="nav-text">moduleMap</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">静涛</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">12.5k</span>
  
</div>

<!--

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>



-->

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <script src="/js/src/md5.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '0754a6946b99dc532c5d',
          clientSecret: 'c8462fd7efc6fbd406f750444cfb7e5071e984a9',
          repo: 'jingtao910429.github.io',
          owner: 'jingtao910429',
          admin: ['jingtao910429'],
          id: md5(window.location.pathname),
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')
       </script>


  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("FYOl8LIbNKWtafIXKjWguSN8-gzGzoHsz", "PmIHJxQUB93QqX6q8nu8DS8n");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

  <script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script>
<script type="text/javascript" src="/lib/clipboard/clipboard.js"></script>
<script type="text/javascript" src="/js/src/custom.js"></script>
</body>
</html>

<!--崩溃欺骗-->
<script type="text/javascript" src="/js/src/crash_cheat.js"></script>

<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>倔强的小码农</title>
    <link>http://jingtaotao.top/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Coder</description>
    <pubDate>Tue, 27 Nov 2018 12:43:04 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>面试相关题目</title>
      <link>http://jingtaotao.top/2018/11/17/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</link>
      <guid>http://jingtaotao.top/2018/11/17/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</guid>
      <pubDate>Sat, 17 Nov 2018 03:55:45 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;1-KVO实现原理&quot;&gt;&lt;a href=&quot;#1-KVO实现原理&quot; class=&quot;headerlink&quot; title=&quot;1.KVO实现原理&quot;&gt;&lt;/a&gt;1.KVO实现原理&lt;/h2&gt;&lt;h3 id=&quot;KVO基本原理&quot;&gt;&lt;a href=&quot;#KVO基本原理&quot; class=&quot;he
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="1-KVO实现原理"><a href="#1-KVO实现原理" class="headerlink" title="1.KVO实现原理"></a>1.KVO实现原理</h2><h3 id="KVO基本原理"><a href="#KVO基本原理" class="headerlink" title="KVO基本原理"></a>KVO基本原理</h3><blockquote><p>1.KVO是基于runtime机制实现的</p><p>2.当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的通知机制</p><p>3.如果原类为Person，那么生成的派生类名为NSKVONotifying_Person</p><p>4.每个类对象中都有一个isa指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法</p><p>5.键值观察通知依赖于NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey:一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey:会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。</p></blockquote><h3 id="KVO深入原理："><a href="#KVO深入原理：" class="headerlink" title="KVO深入原理："></a>KVO深入原理：</h3><blockquote><p>1.Apple 使用了 isa 混写（isa-swizzling）来实现 KVO 。当观察对象A时，KVO机制动态创建一个新的名为： NSKVONotifying_A的新类，该类继承自对象A的本类，且KVO为NSKVONotifying_A重写观察属性的setter 方法，setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象属性值的更改情况。</p><p>2.NSKVONotifying_A类剖析：在这个过程，被观察对象的 isa 指针从指向原来的A类，被KVO机制修改为指向系统新创建的子类 NSKVONotifying_A类，来实现当前类属性值改变的监听；</p><p>3.所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对KVO的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为“NSKVONotifying_A”的类()，就会发现系统运行到注册KVO的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为NSKVONotifying_A的中间类，并指向这个中间类了。</p><p>4.（isa 指针的作用：每个对象都有isa 指针，指向该对象的类，它告诉 Runtime 系统这个对象的类是什么。所以对象注册为观察者时，isa指针指向新子类，那么这个被观察的对象就神奇地变成新子类的对象（或实例）了。） 因而在该对象上对 setter 的调用就会调用已重写的 setter，从而激活键值通知机制</p><p>5.子类setter方法剖析：KVO的键值观察通知依赖于 NSObject 的两个方法:willChangeValueForKey:和 didChangevlueForKey:，在存取数值的前后分别调用2个方法： 被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该 keyPath 的属性值即将变更；当改变发生后， didChangeValueForKey: 被调用，通知系统该 keyPath 的属性值已经变更；之后， observeValueForKey:ofObject:change:context: 也会被调用。且重写观察属性的setter 方法这种继承方式的注入是在运行时而不是编译时实现的。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1829339-77757288cc139f44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="KVO"></p><h2 id="weak实现原理"><a href="#weak实现原理" class="headerlink" title="weak实现原理"></a>weak实现原理</h2><p>Runtime维护了一个weak表，用于存储指向某个对象的所有weak指针。weak表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象的地址）数组。</p><p>1、初始化时：runtime会调用<code>objc_initWeak</code>函数，初始化一个新的weak指针指向对象的地址。</p><p>2、添加引用时：<code>objc_initWeak</code>函数会调用 <code>objc_storeWeak()</code> 函数， <code>objc_storeWeak()</code> 的作用是更新指针指向，创建对应的弱引用表。</p><p>3、释放时，调用<code>clearDeallocating</code>函数。<code>clearDeallocating</code>函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。</p><h3 id="追问的问题一："><a href="#追问的问题一：" class="headerlink" title="追问的问题一："></a>追问的问题一：</h3><p>1.实现weak后，为什么对象释放后会自动为nil？</p><p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为 0 的时候会 dealloc，假如 weak 指向的对象内存地址是 a ，那么就会以 a 为键， 在这个 weak 表中搜索，找到所有以 a 为键的 weak 对象，从而设置为 nil 。</p><h3 id="追问的问题二："><a href="#追问的问题二：" class="headerlink" title="追问的问题二："></a>追问的问题二：</h3><p>2.当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？</p><p>1、调用<code>objc_release</code></p><p>2、因为对象的引用计数为0，所以执行dealloc</p><p>3、在dealloc中，调用了<code>_objc_rootDealloc</code>函数</p><p>4、在<code>_objc_rootDealloc</code>中，调用了<code>object_dispose</code>函数</p><p>5、调用<code>objc_destructInstance</code></p><p>6、最后调用<code>objc_clear_deallocating</code>,详细过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a. 从weak表中获取废弃对象的地址为键值的记录</span><br><span class="line">b. 将包含在记录中的所有附有 weak修饰符变量的地址，赋值为 nil</span><br><span class="line">c. 将weak表中该记录删除</span><br><span class="line">d. 从引用计数表中删除废弃对象的地址为键值的记录</span><br></pre></td></tr></table></figure><h2 id="Controller臃肿优化"><a href="#Controller臃肿优化" class="headerlink" title="Controller臃肿优化"></a>Controller臃肿优化</h2><p>1、添加分类。<br>2、抽象功能类，页面及功能抽出。<br>3、MVVM，部分逻辑放在ViewModel中。<br>4、继承，部分公共功能放在基类中。</p><h2 id="UBT"><a href="#UBT" class="headerlink" title="UBT"></a>UBT</h2><p>SDK 整体上主要包含 4 个部分：AOP、Event Collector、Event Cache、Event Upload。</p><p>SDK 中的这 4 个模块各自的主要功能如下：</p><ul><li>AOP：提供数据收集所需要的时机，即通过 Method Swizzling 来 hook 相应类的方法，然后以 Post Notification 的方式提供出去。</li><li>Event Collector：监听通知，针对当前事件执行相应的数据收集，并将收集的事件数据提交给缓存模块。</li><li>Event Cache：负责事件数据的缓存、序列化以及读取操作，其中包括内存缓存与磁盘缓存。</li><li>Event Upload：基于一定的上报策略执行对已收集的事件数据的上报。</li></ul><h2 id="id和NSObject＊的区别"><a href="#id和NSObject＊的区别" class="headerlink" title="id和NSObject＊的区别"></a>id和NSObject＊的区别</h2><p>id是一个 objc_object 结构体指针，定义是</p><p><code>typedef struct objc_object *id</code></p><p>id可以理解为指向对象的指针。所有oc的对象 id都可以指向，编译器不会做类型检查，id调用任何存在的方法都不会在编译阶段报错，当然如果这个id指向的对象没有这个方法，该崩溃还是会崩溃的。</p><p>NSObject *指向的必须是NSObject的子类，调用的也只能是NSObject里面的方法否则就要做强制类型转换。</p><p>不是所有的OC对象都是NSObject的子类，还有一些继承自NSProxy。NSObject *可指向的类型是id的子集。</p><h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p>管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。</p><p>申请大小：</p><p>栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</p><p>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p><p>碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出</p><p>分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</p><p>分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的。</p><h2 id="高效的实现控件的圆角效果"><a href="#高效的实现控件的圆角效果" class="headerlink" title="高效的实现控件的圆角效果"></a>高效的实现控件的圆角效果</h2><p>1、直接系统方法，<code>cornerRadius</code> 和 <code>maskToBounds</code>，这种方法比较简单，代码量较少，但是操作layer肯定会影响性能，会造成离屏渲染。离屏渲染是指：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">离屏渲染，指的是 GPU 或 CPU 在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。过程中需要切换 contexts (上下文环境),先从当前屏幕切换到离屏的contexts，渲染结束后，又要将 contexts 切换回来，而切换过程十分耗费性能。</span><br></pre></td></tr></table></figure></p><p>2、设计切一张圆角且阴影的图片，使用<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resizableImage(withCapInsets: <span class="type">UIEdgeInsets</span>(top: <span class="number">10</span>, <span class="keyword">left</span>: <span class="number">10</span>, bottom: <span class="number">10</span>, <span class="keyword">right</span>: <span class="number">10</span>), resizingMode: .stretch)</span><br></pre></td></tr></table></figure></p><p>四周不拉伸，拉伸内容<br>3、使用CAShapeLayer和UIBezierPath来设置圆角，消耗内存较小，渲染较快，缺点：操作了layer，对性能有影响，有离屏渲染。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)setLayerAndBezierPathCutCircularWithView:(<span class="type">UIView</span> *) view</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建BezierPath 并设置角 和 半径 这里只设置了 左上 和 右上</span></span><br><span class="line">    <span class="type">UIBezierPath</span> *path = [<span class="type">UIBezierPath</span> bezierPathWithRoundedRect:view.bounds byRoundingCorners:<span class="type">UIRectCornerTopLeft</span> | <span class="type">UIRectCornerTopRight</span> cornerRadii:<span class="type">CGSizeMake</span>(<span class="number">10</span>, <span class="number">10</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="type">CAShapeLayer</span> *layer = [[<span class="type">CAShapeLayer</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    layer.frame = view.bounds;</span><br><span class="line">    layer.path = path.<span class="type">CGPath</span>;</span><br><span class="line">    view.layer.mask = layer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4、使用Core Graphics框架 和 UIBezierPath 画出一个圆角</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)setGraphicsCutCirculayWithView:(<span class="type">UIImageView</span> *) view</span><br><span class="line">&#123;       </span><br><span class="line">                                 <span class="type">UIGraphicsBeginImageContextWithOptions</span>(view.bounds.size, <span class="type">NO</span>, <span class="number">1.0</span>);</span><br><span class="line">    [[<span class="type">UIBezierPath</span> bezierPathWithRoundedRect:view.bounds cornerRadius:<span class="number">5</span>] addClip];</span><br><span class="line">    [view drawRect:view.bounds];</span><br><span class="line">    view.image = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="comment">// 结束</span></span><br><span class="line">    <span class="type">UIGraphicsEndImageContext</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><p>//单层结论并不准确。</p><p>浅复制，单层深复制，完全复制(每一层都深复制) 。</p><p>浅复制也就是所说的指针复制，并没有进行对象复制; </p><p>单层深复制，也就是我们经常说的深复制，我这里说的单层深复制是对于集合类所说的(即NSArray,NSDictionary,NSSet)，单层深复制指的是只复制了该集合类的最外层，里边的元素没有复制，(即这两个集合类的地址不一样，但是两个集合里所存储的元素的地址是一样的); </p><p>完全复制，指的是完全复制整个集合类，也就是说两个集合地址不一样，里边所存储的元素地址也不一样;</p><h3 id="非集合类（NSString，NSNumber）"><a href="#非集合类（NSString，NSNumber）" class="headerlink" title="非集合类（NSString，NSNumber）"></a>非集合类（NSString，NSNumber）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[immutableObject copy]  //浅复制  </span><br><span class="line">[immutableObject mutableCopy] //深复制</span><br><span class="line">[mutableObject copy] //深复制</span><br><span class="line">[mutableObject mutableCopy] //深复制</span><br></pre></td></tr></table></figure><p>结论：不可变进行copy是浅复制，mutableCopy是深复制，可变的copy，mutableCopy都是深复制。</p><h3 id="集合类（NSArray，NSDictionary-NSSet"><a href="#集合类（NSArray，NSDictionary-NSSet" class="headerlink" title="集合类（NSArray，NSDictionary, NSSet)"></a>集合类（NSArray，NSDictionary, NSSet)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[immutableObject copy]  //浅复制</span><br><span class="line">[immutableObject mutableCopy] //单层深复制</span><br><span class="line">[mutableObject copy] //单层深复制</span><br><span class="line">[mutableObject mutableCopy] //单层深复制</span><br></pre></td></tr></table></figure><p>结论：不可变进行copy是浅复制，mutableCopy是单层深复制，可变的copy，mutableCopy都是单层深复制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *copyArray = [[NSArray alloc] initWithArray:array copyItems:YES];  // 完全复制</span><br></pre></td></tr></table></figure></p><p>以上我们所说的两种情况默认都实现了NSCopying和NSMutableCopying协议<br>对于自定义继承自NSObject的类</p><p>copy需要实现NSCopying协议，然后实现以下方法，否则copy会crash</p><p>需要特别注意，可变数组或字典的copy与mutableCopy的区别，<a href="https://blog.csdn.net/Mazy_ma/article/details/51899397" target="_blank" rel="noopener">https://blog.csdn.net/Mazy_ma/article/details/51899397</a></p><h2 id="Struct与Class"><a href="#Struct与Class" class="headerlink" title="Struct与Class"></a>Struct与Class</h2><p>Swift 中类和结构体非常类似，都具有定义和使用属性、方法、下标和构造器等面向对象特性，但是结构体不具有继承性，也不具备运行时强制类型转换、使用析构器和使用引用计等能力。</p><p>Swift 中 struct 是值类型，而 class 是引用类型，所以这篇文章 struct 的行为也可以用到所有的值类型上面，相同地 class 的行为也可以用到引用类型上。</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>   1、安全性：</p><p><code>因为 Struct 是用值类型传递的，它们没有引用计数。</code></p><p>   2、内存：</p><p><code>由于他们没有引用数，他们不会因为循环引用导致内存泄漏。</code><br>   3、速度:</p><p> <code>值类型通常来说是以栈的形式分配的，而不是用堆。因此他们比 Class 要快很多!  (http://stackoverflow.com/a/24243626/596821)</code><br>   4、拷贝：</p><p> <code>Objective-C 里拷贝一个对象,你必须选用正确的拷贝类型（深拷贝、浅拷贝）,而值类型的拷贝则非常轻松！</code><br>   5、线程安全</p><p><code>值类型是自动线程安全的。无论你从哪个线程去访问你的 Struct ，都非常简单。</code></p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>   1、Objective-C</p><p><code>当你的项目的代码是 Swift 和 Objective-C 混合开发时，你会发现在 Objective-C 的代码里无法调用 Swift 的 Struct。因为要在 Objective-C 里调用 Swift 代码的话，对象需要继承于 NSObject。Struct 不是 Objective-C 的好朋友。</code></p><p>   2、继承</p><p><code>Struct 不能相互继承。</code></p><p>   3、NSUserDefaults</p><p><code>Struct 不能被序列化成 NSData 对象。</code></p><h3 id="知识延伸：为什么访问struct比class快？"><a href="#知识延伸：为什么访问struct比class快？" class="headerlink" title="知识延伸：为什么访问struct比class快？"></a>知识延伸：为什么访问struct比class快？</h3><p>“堆”和“栈”并不是数据结构上的Heap跟Stack，而是程序运行中的不同内存空间。栈是程序启动的时候，系统事先分配的，使用过程中，系统不干预；堆是用的时候才向系统申请的，用完了需要交还，这个申请和交还的过程开销相对就比较大了。</p><p>栈是编译时分配空间，而堆是动态分配（运行时分配空间），所以栈的速度快。</p><p>从两方面来考虑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.分配和释放：堆在分配和释放时都要调用函数（MALLOC,FREE)，比如分配时会到堆空间去寻找足够大小的空间（因为多次分配释放后会造成空洞），这些都会花费一定的时间，而栈却不需要这些。</span><br><span class="line"></span><br><span class="line">2.访问时间：访问堆的一个具体单元，需要两次访问内存，第一次得取得指针，第二次才是真正得数据，而栈只需访问一次。</span><br></pre></td></tr></table></figure><h2 id="响应链及RunLoop"><a href="#响应链及RunLoop" class="headerlink" title="响应链及RunLoop"></a>响应链及RunLoop</h2><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p>将UIResponder作为父类派生出如下子类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-UIResponder            </span><br><span class="line"></span><br><span class="line">　　-UIApplication</span><br><span class="line"></span><br><span class="line">　　-UIView</span><br><span class="line"></span><br><span class="line">　　　　-UIControl</span><br><span class="line"></span><br><span class="line">　　-UIViewController</span><br></pre></td></tr></table></figure><p> 1.我们可以看到所有的UIView都继承自UIResponder，这也很容易理解，因为一般的UIView都将在界面上呈现，对于触摸事件都会非常敏感。</p><p> 2.而UIControl类则是UIButton等控件的父类，系统帮助我们将此类控件的共有操作都封装在UIControl中。</p><p> 3.对于UIApplication和UIViewController不像UIView那样可被触摸，但是不要忘记了UIResponder除了可以处理触摸事件外还可以进行其他事件的处理，而这些事件会被响应者链机制传递到 UIApplication和UIViewController。</p><p>UIResponder 是 UIView 的父类。responder 能够处理触摸、手势、远程控制等事件。之所以它是一个单独的类而没有合并到 UIView 中，是因为 UIResponder 有更多的子类，最明显的就是 UIApplication 和 UIViewController。</p><p>UIView 子类处理所有跟内容绘制有关的事情以及触摸时间。<br>UIControl 建立在视图上，增加了更多的交互支持。最重要的是，它增加了 target / action 模式。UIView通过delegate交互。</p><h3 id="响应链大概有以下几个步骤："><a href="#响应链大概有以下几个步骤：" class="headerlink" title="响应链大概有以下几个步骤："></a>响应链大概有以下几个步骤：</h3><blockquote><p>设备将touch到的UITouch和UIEvent对象打包, 放到当前活动的Application的事件队列中</p></blockquote><blockquote><p>单例的UIApplication会从事件队列中取出触摸事件并传递给单例UIWindow</p></blockquote><blockquote><p>UIWindow使用hitTest:withEvent:方法查找touch操作的所在的视图view</p></blockquote><h3 id="RunLoop-的作用"><a href="#RunLoop-的作用" class="headerlink" title="RunLoop 的作用"></a>RunLoop 的作用</h3><p>1.保证程序不退出保活线程，它就是一个死循环：”接受事件 -&gt; …等待 -&gt; 处理”</p><p>2.负责监听管理事件，触摸事件（用户交互事件）、时钟事件（Timer）、网络事件（网络请求回调接收等）以及系统事件内核事件；</p><p>3.如果没有事件则进入睡眠状态</p><h3 id="CFRunLoopMode的类型"><a href="#CFRunLoopMode的类型" class="headerlink" title="CFRunLoopMode的类型"></a>CFRunLoopMode的类型</h3><blockquote><ol><li>kCFRunLoopDefaultMode<br><code>App的默认Mode，通常主线程是在这个Mode下运行</code></li></ol></blockquote><blockquote><ol start="2"><li>UITrackingRunLoopMode：<br><code>界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</code></li><li>UIInitializationRunLoopMode:<br><code>在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用</code></li><li>GSEventReceiveRunLoopMode:<br><code>接受系统事件的内部 Mode，通常用不到</code></li><li>kCFRunLoopCommonModes:<br><code>这是一个占位用的Mode，作为标记kCFRunLoopDefaultMode和UITrackingRunLoopMode用，并不是一种真正的Mode</code></li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RunLoop这边我大概讲一下：</span><br><span class="line"></span><br><span class="line">主线程的RunLoop被唤醒</span><br><span class="line"></span><br><span class="line">通知Observer，处理Timer和Source 0</span><br><span class="line"></span><br><span class="line">Springboard接受touch event之后转给App进程</span><br><span class="line"></span><br><span class="line">RunLoop处理Source 1，Source1 就会触发回调，并调用_UIApplicationHandleEventQueue() 进行应用内部的分发。</span><br><span class="line"></span><br><span class="line">RunLoop处理完毕进入睡眠，此前会释放旧的autorelease pool并新建一个autorelease pool</span><br></pre></td></tr></table></figure><h2 id="NStimer准吗？谈谈你的看法？如果不准该怎样实现一个精确的NSTimer"><a href="#NStimer准吗？谈谈你的看法？如果不准该怎样实现一个精确的NSTimer" class="headerlink" title=".NStimer准吗？谈谈你的看法？如果不准该怎样实现一个精确的NSTimer?"></a>.NStimer准吗？谈谈你的看法？如果不准该怎样实现一个精确的NSTimer?</h2><p>1.不准</p><p>2.不准的原因如下：</p><p>1、NSTimer加在main runloop中，模式是NSDefaultRunLoopMode，main负责所有主线程事件，例如UI界面的操作，复杂的运算，这样在同一个runloop中timer就会产生阻塞。</p><p>2、模式的改变。主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。</p><p>当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个ScrollView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。所以就会影响到NSTimer不准的情况。</p><p>PS:DefaultMode 是 App 平时所处的状态，rackingRunLoopMode 是追踪 ScrollView 滑动时的状态。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>1、在主线程中进行NSTimer操作，但是将NSTimer实例加到main runloop的特定mode（模式）中。避免被复杂运算操作或者UI界面刷新所干扰。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.timer = [<span class="type">NSTimer</span> timerWithTimeInterval:<span class="number">1</span> target:<span class="keyword">self</span> selector:@selector(showTime) userInfo:<span class="literal">nil</span> repeats:<span class="type">YES</span>];</span><br><span class="line"></span><br><span class="line">[[<span class="type">NSRunLoop</span> currentRunLoop] addTimer:<span class="keyword">self</span>.timer forMode:<span class="type">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure></p><p>2、在子线程中进行NSTimer的操作，再在主线程中修改UI界面显示操作结果；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (void)timerMethod2 &#123;</span><br><span class="line"></span><br><span class="line">NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];</span><br><span class="line"></span><br><span class="line">[thread start];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)newThread</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">@autoreleasepool</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">[NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(showTime) userInfo:nil repeats:YES];</span><br><span class="line"></span><br><span class="line">[[NSRunLoop currentRunLoop] run];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line"></span><br><span class="line">一开始的时候系统就为我们将主线程的main runloop隐式的启动了。</span><br><span class="line"></span><br><span class="line">在创建线程的时候，可以主动获取当前线程的runloop。每个子线程对应一个runloop</span><br></pre></td></tr></table></figure></p><h3 id="方法二：直接使用GCD替代！GCD创建的定时器不受RunLoop中Modes影响"><a href="#方法二：直接使用GCD替代！GCD创建的定时器不受RunLoop中Modes影响" class="headerlink" title="方法二：直接使用GCD替代！GCD创建的定时器不受RunLoop中Modes影响"></a>方法二：直接使用GCD替代！GCD创建的定时器不受RunLoop中Modes影响</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义需要计时的时间</span></span><br><span class="line"><span class="keyword">var</span> timeCount = <span class="number">60</span></span><br><span class="line"><span class="comment">// 在global线程里创建一个时间源</span></span><br><span class="line"><span class="keyword">let</span> codeTimer = <span class="type">DispatchSource</span>.makeTimerSource(queue:      <span class="type">DispatchQueue</span>.global())</span><br><span class="line"><span class="comment">// 设定这个时间源是每秒循环一次，立即开始</span></span><br><span class="line">codeTimer.schedule(deadline: .now(), repeating: .seconds(<span class="number">1</span>))</span><br><span class="line"><span class="comment">// 设定时间源的触发事件</span></span><br><span class="line">codeTimer.setEventHandler(handler: &#123;</span><br><span class="line">    <span class="comment">// 每秒计时一次</span></span><br><span class="line">    timeCount = timeCount - <span class="number">1</span></span><br><span class="line">    <span class="comment">// 时间到了取消时间源</span></span><br><span class="line">    <span class="keyword">if</span> timeCount &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        codeTimer.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回主线程处理一些事件，更新UI等等</span></span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 启动时间源</span></span><br><span class="line">codeTimer.resume()</span><br></pre></td></tr></table></figure><h2 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h2><p>1).代码区：存放函数二进制代码</p><p>2).数据区：系统运行时申请内存并初始化，系统退出时由系统释放。存放全局变量、静态变量、常量</p><p>3).堆区：通过malloc等函数或new等操作符动态申请得到，需程序员手动申请和释放</p><p>4).栈区：函数模块内申请，函数结束时由系统自动释放。存放局部变量、函数参数</p><h2 id="block和函数指针的理解"><a href="#block和函数指针的理解" class="headerlink" title="block和函数指针的理解"></a>block和函数指针的理解</h2><p>相似点：</p><p>函数指针和Block都可以实现回调的操作，声明上也很相似，实现上都可以看成是一个代码片段。</p><p>函数指针类型和Block类型都可以作为变量和函数参数的类型。（typedef定义别名之后，这个别名就是一个类型）</p><p>不同点：</p><p>函数指针只能指向预先定义好的函数代码块（可以是其他文件里面定义，通过函数参数动态传入的），函数地址是在编译链接时就已经确定好的。</p><p>Block本质是Objective-C对象，是NSObject的子类，可以接收消息。</p><p>函数里面只能访问全局变量，而Block代码块不光能访问全局变量，还拥有当前栈内存和堆内存变量的可读性（当然通过__block访问指示符修饰的局部变量还可以在block代码块里面进行修改）。</p><p>从内存的角度看，函数指针只不过是指向代码区的一段可执行代码，而block实际上是程序运行过程中在栈内存动态创建的对象，可以向其发送copy消息将block对象拷贝到堆内存，以延长其生命周期。</p><h2 id="对象内存结构中的-isa-指针是用来做什么的？"><a href="#对象内存结构中的-isa-指针是用来做什么的？" class="headerlink" title="对象内存结构中的 isa 指针是用来做什么的？"></a>对象内存结构中的 isa 指针是用来做什么的？</h2><p>问题:Objective-C 对象内存结构中的 isa 指针是用来做什么的，有什么用？<br>答案:Objective-C 是一门面向对象的编程语言。每一个对象都是一个类的实例。在 Objective-C 语言的内部，每一个对象都有一个名为 isa 的指针，指向该对象的类。每一个类描述了一系列它的实例的特点，包括成员变量的列表，成员函数的列表等。每一个对象都可以接受消息，而对象能够接收的消息列表是保存在它所对应的类中。</p><p>在 Xcode 中按Shift + Command + O, 然后输入 NSObject.h 和 objc.h，可以打开 NSObject 的定义头文件，通过头文件我们可以看到，NSObject 就是一个包含 isa 指针的结构体，如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1448717-f1923f87d53bd277.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="isa结构体"></p><p>按照面向对象语言的设计原则，所有事物都应该是对象（严格来说 Objective-C 并没有完全做到这一点，因为它有象 int, double 这样的简单变量类型，而 Swift 语言，连 int 变量也是对象）。在 Objective-C 语言中，每一个类实际上也是一个对象。每一个类也有一个名为 isa 的指针。每一个类也可以接受消息，例如代码[NSObject alloc]，就是向 NSObject 这个类发送名为alloc消息。</p><p>在 Xcode 中按Shift + Command + O, 然后输入 runtime.h，可以打开 Class 的定义头文件，通过头文件我们可以看到，Class 也是一个包含 isa 指针的结构体，如下图所示。（图中除了 isa 外还有其它成员变量，但那是为了兼容非 2.0 版的 Objective-C 的遗留逻辑，大家可以忽略它。）</p><p>因为类也是一个对象，那它也必须是另一个类的实列，这个类就是元类 (metaclass)。元类保存了类方法的列表。当一个类方法被调用时，元类会首先查找它本身是否有该类方法的实现，如果没有，则该元类会向它的父类查找该方法，直到一直找到继承链的头。</p><p>元类 (metaclass) 也是一个对象，那么元类的 isa 指针又指向哪里呢？为了设计上的完整，所有的元类的 isa 指针都会指向一个根元类 (root metaclass)。根元类 (root metaclass) 本身的 isa 指针指向自己，这样就行成了一个闭环。上面提到，一个对象能够接收的消息列表是保存在它所对应的类中的。在实际编程中，我们几乎不会遇到向元类发消息的情况，那它的 isa 指针在实际上很少用到。不过这么设计保证了面向对象概念在 Objective-C 语言中的完整，即语言中的所有事物都是对象，都有 isa 指针。</p><p>我们再来看看继承关系，由于类方法的定义是保存在元类 (metaclass) 中，而方法调用的规则是，如果该类没有一个方法的实现，则向它的父类继续查找。所以，为了保证父类的类方法可以在子类中可以被调用，所以子类的元类会继承父类的元类，换而言之，类对象和元类对象有着同样的继承关系。</p><p>我很想把关系说清楚一些，但是这块儿确实有点绕，我们还是来看图吧，很多时候图象比文字表达起来更为直观。下面这张图或许能够让大家对 isa 和继承的关系清楚一些：</p><p><img src="http://upload-images.jianshu.io/upload_images/1448717-c23167e42658955d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="isa继承"></p><p>我们可以从图中看出：</p><p>NSObject 的类中定义了实例方法，例如 -(id)init 方法 和 - (void)dealloc 方法。<br>NSObject 的元类中定义了类方法，例如 +(id)alloc 方法 和 + (void)load 、+ (void)initialize 方法。<br>NSObject 的元类继承自 NSObject 类，所以 NSObject 类是所有类的根，因此 NSObject 中定义的实例方法可以被所有对象调用，例如 - (id)init 方法 和 - (void)dealloc 方法。<br>NSObject 的元类的 isa 指向自己。<br>isa swizzling 的应用</p><p>系统提供的 KVO 的实现，就利用了动态地修改 isa 指针的值的技术。在 苹果的文档<br>中可以看到如下描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Key-Value Observing Implementation Details</span><br><span class="line">Automatic key-value observing is implemented using a technique called isa-swizzling.</span><br><span class="line">The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</span><br><span class="line">When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</span><br><span class="line">You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</span><br></pre></td></tr></table></figure><h2 id="iOS-Runtime详解"><a href="#iOS-Runtime详解" class="headerlink" title="iOS Runtime详解"></a>iOS Runtime详解</h2><p><a href="https://www.jianshu.com/p/6ebda3cd8052" target="_blank" rel="noopener">https://www.jianshu.com/p/6ebda3cd8052</a></p><h2 id="NSCache"><a href="#NSCache" class="headerlink" title="NSCache"></a>NSCache</h2><p>SD图片缓存就用的该类 一个可变集合，用于临时存储临时键值对，在资源不足的情况下被释放。<br>NSCache类包含了各种自动释放内存的机制，可以确保缓存不会占用太多的系统内存。如果其他应用程序需要内存，这些机制会从缓存中删除一些项目，从而最大限度地减少其内存占用。<br>您可以从不同的线程中添加，删除和查询缓存中的项目，而无需自己锁定缓存。<br>与NSMutableDictionary对象不同，缓存不会复制放入其中的关键对象。<br>您通常使用NSCache对象临时存储对象与创建重要的临时数据。重用这些对象可以提供性能优势，因为它们的值不必重新计算。但是，这些对象对应用程序并不重要，如果内存不足，可以将其释放。如果释放，则需要时重新计算它们的值。<br>具有可以在不使用时释放的子组件的对象可以采用NSDiscardableContent协议来改善缓存机制的行为。默认情况下，如果缓存中的NSDiscardableContent对象的内容被释放，它们将被自动删除，尽管这个自动删除机制是可以改变的。如果一个NSDiscardableContent对象被放入缓存中，缓存在移除时调用discardContentIfPossible。</p><h2 id="如果项目开始容错处理没做？如何防止拦截潜在的崩溃？"><a href="#如果项目开始容错处理没做？如何防止拦截潜在的崩溃？" class="headerlink" title="如果项目开始容错处理没做？如何防止拦截潜在的崩溃？"></a>如果项目开始容错处理没做？如何防止拦截潜在的崩溃？</h2><p>例：</p><p>1、category给类添加方法用来替换掉原本存在潜在崩溃的方法。</p><p>2、利用runtime方法交换技术，将系统方法替换成类添加的新方法。</p><p>3、利用异常的捕获来防止程序的崩溃，并且进行相应的处理。</p><p>总结：</p><p>1、不要过分相信服务器返回的数据会永远的正确。</p><p>2、在对数据处理上，要进行容错处理，进行相应判断之后再处理数据，这是一个良好的编程习惯。</p><h2 id="内存泄漏的几种情况"><a href="#内存泄漏的几种情况" class="headerlink" title="内存泄漏的几种情况"></a>内存泄漏的几种情况</h2><p>答：循环引用：delegate，block，timer等</p><p>图片没释放，instrument调试后，发现没被释放的全是imageIO，差不多就知道了，把读图的方式，从[UIImage imageNamed:@””],改成imageWithContentsOfFile，就可以了。</p><p>CoreFoundation对象(C对象) : 只要函数中包含了create\new\copy\retain等关键字, 那么这些方法产生的对象, 就必须在不再使用的时候调用1次CFRelease或者其他release函数</p><p>地图，蓝牙等框架的使用，在根据文档实现某地图，蓝牙相关功能的同时，我们需要注意内存的正确释放，大体需要注意的有需在使用完毕时将地图、代理等滞空为nil，注意地图中标注（大头针）的复用，保存蓝牙设备的数据源清空，使用完毕时清空标注数组等。</p><p>大数量的循环，该循环内产生大量的临时对象，直至循环结束才释放，可能导致内存泄漏，解决方法为在循环中创建自己的autoReleasePool，及时释放占用内存大的临时变量，减少内存占用峰值。</p><h2 id="主线程死锁"><a href="#主线程死锁" class="headerlink" title="主线程死锁"></a>主线程死锁</h2><h2 id="同步、异步-与-串行、并行的区别"><a href="#同步、异步-与-串行、并行的区别" class="headerlink" title="同步、异步 与 串行、并行的区别"></a>同步、异步 与 串行、并行的区别</h2><p>同步、异步：</p><p>指的是能否开启新的线程。同步不能开启新的线程，异步可以。</p><p>串行、并行：</p><p>指的是任务的执行方式。串行是指多个任务时，各个任务按顺序执行，完成一个之后才能进行下一个。并行指的是多个任务可以同时执行。异步是多个任务并行的前提条件。</p><p>并发和并行:</p><p>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。</p><h2 id="GCD-和-NSOperation-进行比较"><a href="#GCD-和-NSOperation-进行比较" class="headerlink" title="GCD 和 NSOperation 进行比较"></a>GCD 和 NSOperation 进行比较</h2><p>(1).NSOperation 是对 GCD 的封装，面相对象的类，GCD 只是一组方法 API。</p><p>(2).NSOperation 可以实现一些 GCD 中实现不了，或者实现比较复杂的功能。比如：设置最大并发数，设置线程间的依赖关系。</p><p>(3).实现某个多线程功能，使用 GCD，简单易用。实现某个多线程模块，使用 NSOperation，方便类的管理。</p><h2 id="strong和copy的区别"><a href="#strong和copy的区别" class="headerlink" title="strong和copy的区别"></a>strong和copy的区别</h2><p>代码示例</p><p>还是结合代码来说明这个情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">@property (strong, nonatomic) NSArray *bookArray1;</span><br><span class="line">@property (copy, nonatomic) NSArray *bookArray2;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">//省略setter方法</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//Person调用</span><br><span class="line">main()&#123;</span><br><span class="line">    NSMutableArray *books = [@[@&quot;book1&quot;] mutableCopy];</span><br><span class="line">    Person *person = [[Person alloc] init];</span><br><span class="line">    person.bookArray1 = books;</span><br><span class="line">    person.bookArray2 = books;</span><br><span class="line">    [books addObject:@&quot;book2&quot;];</span><br><span class="line">    NSLog(@&quot;bookArray1:%@&quot;,person.bookArray1);</span><br><span class="line">    NSLog(@&quot;bookArray2:%@&quot;,person.bookArray2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，使用strong修饰的person.bookArray1输出是[book1,book2]，而使用copy修饰的person.bookArray2输出是[book1]。这下可以看出来区别了吧。</p><p>备注：使用strong，则person.bookArray1与可变数组books指向同一块内存区域，books内容改变，导致person.bookArray1的内容改变，因为两者是同一个东西；而使用copy，person.bookArray2在赋值之前，将books内容复制，创建一个新的内存区域，所以两者不是一回事，books的改变不会导致person.bookArray2的改变。<br>说到底，其实就是不同的修饰符，对应不同的setter方法，</p><ol><li>strong对应的setter方法，是将_property先release（_property release），然后将参数retain（property retain），最后是_property = property。</li><li>copy对应的setter方法，是将_property先release（_property release），然后拷贝参数内容（property copy），创建一块新的内存地址，最后_property = property。</li></ol><p>retain是指针拷贝，copy是内容拷贝。在拷贝之前，都会释放旧的对象。</p><p><a href="https://blog.csdn.net/haha_hello/article/details/67106284" target="_blank" rel="noopener">https://blog.csdn.net/haha_hello/article/details/67106284</a></p><h2 id="NSSet"><a href="#NSSet" class="headerlink" title="NSSet"></a>NSSet</h2><p><a href="https://www.douban.com/note/609880170/" target="_blank" rel="noopener">https://www.douban.com/note/609880170/</a><br><a href="https://www.jianshu.com/p/915356e280fc" target="_blank" rel="noopener">https://www.jianshu.com/p/915356e280fc</a></p><h2 id="block的修饰词为什么选用copy"><a href="#block的修饰词为什么选用copy" class="headerlink" title="block的修饰词为什么选用copy"></a>block的修饰词为什么选用copy</h2><p><a href="https://www.cnblogs.com/jingxin1992/p/7145596.html" target="_blank" rel="noopener">https://www.cnblogs.com/jingxin1992/p/7145596.html</a></p><h2 id="修改readonly属性的值"><a href="#修改readonly属性的值" class="headerlink" title="修改readonly属性的值"></a>修改readonly属性的值</h2><p>kvc来设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[stu setValue:@&quot;胡说&quot; forKey:NSStringFromSelector(@selector(hisName))];</span><br></pre></td></tr></table></figure></p><p>若想禁止kvc修改readonly属性的值，则可以在定义readonly属性的类中添加该方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//默认返回为YES，表示可允许修改。改为NO即可</span><br><span class="line">+(BOOL)accessInstanceVariablesDirectly&#123;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结:</p><p>当我们声明一个 readonly 的属性，外部可能会通过 KVC 修改该属性值。<br>为了避免 KVC 修改属性值，须将定义属性所在类的类方法 + (BOOL)accessInstanceVariablesDirectly 重写，使其返回 NO.</p><h2 id="TCP三次握手和四次挥手"><a href="#TCP三次握手和四次挥手" class="headerlink" title="TCP三次握手和四次挥手"></a>TCP三次握手和四次挥手</h2><p><a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">https://blog.csdn.net/qzcsu/article/details/72861891</a></p><h2 id="为什么assign不能用于修饰对象？"><a href="#为什么assign不能用于修饰对象？" class="headerlink" title="为什么assign不能用于修饰对象？"></a>为什么assign不能用于修饰对象？</h2><p>首先我们需要明确，对象的内存一般被分配到堆上，基本数据类型和oc数据类型的内存一般被分配在栈上。</p><p>如果用assign修饰对象，当对象被释放后，指针的地址还是存在的，也就是说指针并没有被置为nil，从而造成了野指针。因为对象是分配在堆上的，堆上的内存由程序员分配释放。而因为指针没有被置为nil,如果后续的内存分配中，刚好分配到了这块内存，就会造成崩溃。<br>如果用assign修饰对象，当对象释放后（因为不存在强引用，离开作用域对象内存可能被回收），指针的地址还是存在的，也就是说指针并没有被置为nil,下次再访问该对象就会造成野指针异常。对象是分配在堆上的，堆上的内存由程序员手动释放。</p><p>而assign修饰基本数据类型或oc数据类型，因为基本数据类型是分配在栈上的，由系统分配和释放，所以不会造成野指针。</p><h2 id="在子线程中无法调用selector方法"><a href="#在子线程中无法调用selector方法" class="headerlink" title="在子线程中无法调用selector方法"></a>在子线程中无法调用selector方法</h2><p>在子线程中无法调用selector方法这种情况是只有使用以下方法的时候才出现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)performSelector:(SEL)aSelector withObject:(id)arg afterDelay:(NSTimeInterval)delay;</span><br></pre></td></tr></table></figure><p>这是为什么呢？原因如下：</p><p>1、afterDelay方式是使用当前线程的RunLoop中根据afterDelay参数创建一个Timer定时器在一定时间后调用SEL，NO AfterDelay方式是直接调用SEL。</p><p>2、子线程中默认是没有runloop的，需要手动创建，只要调用获取当前线程RunLoop方法即可创建。</p><p>所以解决方法有两种：</p><p>创建子线程的runloop<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">    [self performSelector:@selector(delayMethod) withObject:nil afterDelay:0];</span><br><span class="line">    [[NSRunLoop currentRunLoop] run];</span><br><span class="line">    NSLog(@&quot;调用方法＝＝开始&quot;);</span><br><span class="line">    sleep(5);</span><br><span class="line">    NSLog(@&quot;调用方法＝＝结束&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><a href="https://www.jianshu.com/p/672c0d4f435a" target="_blank" rel="noopener">https://www.jianshu.com/p/672c0d4f435a</a></p><h2 id="NSThread、NSRunLoop-和-NSAutoreleasePool三者之间的关系"><a href="#NSThread、NSRunLoop-和-NSAutoreleasePool三者之间的关系" class="headerlink" title="NSThread、NSRunLoop 和 NSAutoreleasePool三者之间的关系"></a>NSThread、NSRunLoop 和 NSAutoreleasePool三者之间的关系</h2><p>NSThread 和 NSRunLoop是一一对应的关系<br>在NSRunLoop对象的每个运行循环（event loop）开始前，系统会自动创建一个autoreleasepool，并在运行循环（event loop）结束时drain掉这个pool，同时释放所有autoreleased对象<br>autoreleasepool只会对应一个线程，每个线程可能会对应多个autoreleasepool，比如autoreleasepool嵌套的情况</p><h2 id="autorelease-实现原理"><a href="#autorelease-实现原理" class="headerlink" title="autorelease 实现原理"></a>autorelease 实现原理</h2><p><a href="https://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">https://blog.sunnyxx.com/2014/10/15/behind-autorelease/</a></p><h2 id="atomic-nonatomic的内部底层原理探究"><a href="#atomic-nonatomic的内部底层原理探究" class="headerlink" title="atomic,nonatomic的内部底层原理探究"></a>atomic,nonatomic的内部底层原理探究</h2><p>atomic与nonatomicd的主要区别就是系统自动生成的getter/setter方法不一样</p><p>atomic系统自动生成的getter/setter方法会进行加锁操作<br>nonatomic系统自动生成的getter/setter方法不会进行加锁操作</p><p>1、内部实现</p><p>在 objc4-723 的 Objective-C runtime 实现中，property 的 atomic 是采用 spinlock_t 也就是俗称的自旋锁实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// getter</span><br><span class="line">id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) </span><br><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">    if (!atomic) return *slot;</span><br><span class="line"></span><br><span class="line">    // Atomic retain release world</span><br><span class="line">    spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">    slotlock.lock();</span><br><span class="line">    id value = objc_retain(*slot);</span><br><span class="line">    slotlock.unlock();</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// setter</span><br><span class="line">static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)</span><br><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">    if (!atomic) </span><br><span class="line">&#123;</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;</span><br><span class="line">    &#125; </span><br><span class="line">else </span><br><span class="line">&#123;</span><br><span class="line">        spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;        </span><br><span class="line">        slotlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、能否保证线程安全？</p><p>atomic通过这种方法，在运行时保证 set,get方法的原子性。<br>仅仅是保证了set,get方法的原子性。<br>这种线程是不安全的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@property (atomic, assign)    int       intA;</span><br><span class="line"></span><br><span class="line">//线程A</span><br><span class="line">for (int i = 0; i &lt; 10000; i ++) </span><br><span class="line">&#123;</span><br><span class="line">    self.intA = self.intA + 1;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;Thread A: %d\n&quot;, self.intA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//线程B</span><br><span class="line">for (int i = 0; i &lt; 10000; i ++) </span><br><span class="line">&#123;</span><br><span class="line">    self.intA = self.intA + 1;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;Thread B: %d\n&quot;, self.intA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>self.intA 是原子操作，但是self.intA = self.intA + 1这个表达式并不是原子操作。<br>所以线程是不安全的。<br>threadA 在执行表达式 self.intA之后 self.intA = self.intA + 1;并没有执行完毕<br>此时threadB 执行self.intA = self.intA + 1;<br>再回到threadA时，self.intA的数值就被更新了</p><p>所以仅仅使用atomic并不能保证线程安全。</p><p>网上还有其他实现，如同步锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (UITextField *) userName &#123;</span><br><span class="line">    UITextField *retval = nil;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        retval = [[userName retain] autorelease];</span><br><span class="line">    &#125;</span><br><span class="line">    return retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) setUserName:(UITextField *)userName_ &#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">      [userName release];</span><br><span class="line">      userName = [userName_ retain];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://blog.csdn.net/CHENYUFENG1991/article/details/49687215" target="_blank" rel="noopener">https://blog.csdn.net/CHENYUFENG1991/article/details/49687215</a></p><h2 id="Swift相关"><a href="#Swift相关" class="headerlink" title="Swift相关"></a>Swift相关</h2><h2 id="Optional实质"><a href="#Optional实质" class="headerlink" title="Optional实质"></a>Optional实质</h2><p>Optional Type 的本质是一个枚举类型，拆包其实相当于switch &amp; case<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A type that can represent either a `Wrapped` value or `nil`, the absence</span></span><br><span class="line"><span class="comment">/// of a value.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Optional</span>&lt;<span class="title">Wrapped</span>&gt; : <span class="title">_Reflectable</span>, <span class="title">NilLiteralConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Some</span>(<span class="type">Wrapped</span>)</span><br><span class="line">    <span class="comment">/// Construct a `nil` instance.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>()</span><br><span class="line">    <span class="comment">/// Construct a non-`nil` instance that stores `some`.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> some: <span class="type">Wrapped</span>)</span><br><span class="line">    <span class="comment">/// If `self == nil`, returns `nil`.  Otherwise, returns `f(self!)`.</span></span><br><span class="line">    <span class="meta">@warn_unused_result</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;U&gt;<span class="params">(@noescape f: <span class="params">(Wrapped)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">U</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">U</span>?</span><br><span class="line">    <span class="comment">/// Returns `nil` if `self` is `nil`, `f(self!)` otherwise.</span></span><br><span class="line">    <span class="meta">@warn_unused_result</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;U&gt;<span class="params">(@noescape f: <span class="params">(Wrapped)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">U</span>?) <span class="keyword">rethrows</span> -&gt; <span class="type">U</span>?</span><br><span class="line">    <span class="comment">/// Create an instance initialized with `nil`.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(nilLiteral: ())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Swift-mutating关键字的使用"><a href="#Swift-mutating关键字的使用" class="headerlink" title="Swift - mutating关键字的使用"></a>Swift - mutating关键字的使用</h2><p>Swift中protocol的功能比OC中强大很多，不仅能再class中实现，同时也适用于struct、enum。<br>使用 mutating 关键字修饰方法是为了能在该方法中修改 struct 或是 enum 的变量，在设计接口的时候，也要考虑到使用者程序的扩展性。所以要多考虑使用mutating来修饰方法。</p><h2 id="SDWebImage原理和缓存机制"><a href="#SDWebImage原理和缓存机制" class="headerlink" title="SDWebImage原理和缓存机制"></a>SDWebImage原理和缓存机制</h2><p><a href="https://www.jianshu.com/p/7dea5b081d24" target="_blank" rel="noopener">https://www.jianshu.com/p/7dea5b081d24</a><br><a href="https://blog.csdn.net/fucuiping_1314/article/details/79035138" target="_blank" rel="noopener">https://blog.csdn.net/fucuiping_1314/article/details/79035138</a></p><h2 id="利用CADisplayLink的与屏幕刷新同步调用的特性"><a href="#利用CADisplayLink的与屏幕刷新同步调用的特性" class="headerlink" title="利用CADisplayLink的与屏幕刷新同步调用的特性"></a>利用CADisplayLink的与屏幕刷新同步调用的特性</h2><h2 id="RunTime详解"><a href="#RunTime详解" class="headerlink" title="RunTime详解"></a>RunTime详解</h2><p><a href="https://www.jianshu.com/p/6ebda3cd8052" target="_blank" rel="noopener">https://www.jianshu.com/p/6ebda3cd8052</a></p><h2 id="moduleMap"><a href="#moduleMap" class="headerlink" title="moduleMap"></a>moduleMap</h2><p><a href="https://blog.dianqk.org/2017/05/01/dev-on-pod/" target="_blank" rel="noopener">https://blog.dianqk.org/2017/05/01/dev-on-pod/</a></p>]]></content:encoded>
      
      <comments>http://jingtaotao.top/2018/11/17/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>设计模式之结构型模式-适配器模式</title>
      <link>http://jingtaotao.top/2018/10/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <guid>http://jingtaotao.top/2018/10/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <pubDate>Wed, 31 Oct 2018 09:48:25 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;适配器模式通过引入适配器对两个组件进行适配，可以让两个API不兼容的组件协作。此模式可以将无法修改源码的组件集成到应用中，在使用第三方框架或利用另外一个项目输出的数据时，通常会遇到组件之间的兼容问题。&lt;/p&gt;
&lt;h2 id=&quot;适配器模式相关概念&quot;&gt;&lt;a href=&quot;#适配器
        
      
      </description>
      
      <content:encoded><![CDATA[<p>适配器模式通过引入适配器对两个组件进行适配，可以让两个API不兼容的组件协作。此模式可以将无法修改源码的组件集成到应用中，在使用第三方框架或利用另外一个项目输出的数据时，通常会遇到组件之间的兼容问题。</p><h2 id="适配器模式相关概念"><a href="#适配器模式相关概念" class="headerlink" title="适配器模式相关概念"></a>适配器模式相关概念</h2><p><strong>意图：</strong> 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p><strong>解决：</strong> <code>Extension</code>或者<code>适配器包装类</code>，<code>双向适配器</code></p><p><strong>优点：</strong>  1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。</p><p><strong>缺点：</strong> 过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。所以，适配器模式还是慎用。</p><h2 id="适配器模式使用场景"><a href="#适配器模式使用场景" class="headerlink" title="适配器模式使用场景"></a>适配器模式使用场景</h2><p>如下代码定义了 <code>Employee</code> 和 接口 <code>EmployDataSource</code>，员工信息<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">EmployDataSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> employees: [<span class="type">Employee</span>] &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(name: String)</span></span> -&gt; [<span class="type">Employee</span>]</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(title: String)</span></span> -&gt; [<span class="type">Employee</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现<code>DataSourceBase</code>基类。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataSourceBase</span>: <span class="title">EmployDataSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> employees: [<span class="type">Employee</span>] = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(<span class="built_in">filter</span>: <span class="params">(Employee)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; [<span class="type">Employee</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> results: [<span class="type">Employee</span>] = []</span><br><span class="line">        <span class="keyword">for</span> emp <span class="keyword">in</span> employees &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">filter</span>(emp) &#123;</span><br><span class="line">                results.append(emp)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(name: String)</span></span> -&gt; [<span class="type">Employee</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> search(<span class="built_in">filter</span>: &#123; (employee) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> employee.name?.range(of: name) != <span class="literal">nil</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(title: String)</span></span> -&gt; [<span class="type">Employee</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> search(<span class="built_in">filter</span>: &#123; (employee) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> employee.title?.range(of: title) != <span class="literal">nil</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义两个不同的部门</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalesDataSource</span>: <span class="title">DataSourceBase</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        employees.append(<span class="type">Employee</span>(name: <span class="string">"销售1"</span>, title: <span class="string">"VP"</span>))</span><br><span class="line">        employees.append(<span class="type">Employee</span>(name: <span class="string">"销售2"</span>, title: <span class="string">"Account"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DevelopmentDataSource</span>: <span class="title">DataSourceBase</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        employees.append(<span class="type">Employee</span>(name: <span class="string">"开发1"</span>, title: <span class="string">"iOS"</span>))</span><br><span class="line">        employees.append(<span class="type">Employee</span>(name: <span class="string">"开发2"</span>, title: <span class="string">"Andorid"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义<code>SearchTool</code>用于对<code>Employee</code>的搜索。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SearchTool</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">SearchType</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> name</span><br><span class="line">        <span class="keyword">case</span> title</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">let</span> sources: [<span class="type">EmployDataSource</span>]</span><br><span class="line">    <span class="comment">//在init方法里我们可以对let的实例变量进行赋值，这是初始化方法的重要特点。</span></span><br><span class="line">    <span class="comment">//在Swift中let声明的值是常量，无法被写入赋值，这对于构建线程安全的API十分有用。</span></span><br><span class="line">    <span class="comment">//而因为Swift的init只可能被调用一次，因此在init中我们可以为常量进行赋值，而不会引起任何线程安全的问题.</span></span><br><span class="line">    <span class="keyword">init</span>(dataSource: <span class="type">EmployDataSource</span>...) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sources = dataSource</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> employees: [<span class="type">Employee</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> results: [<span class="type">Employee</span>] = []</span><br><span class="line">        <span class="keyword">for</span> source <span class="keyword">in</span> sources &#123;</span><br><span class="line">            results += source.employees</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(text: String, searchType: SearchType)</span></span> -&gt; [<span class="type">Employee</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> results: [<span class="type">Employee</span>] = []</span><br><span class="line">        <span class="keyword">for</span> source <span class="keyword">in</span> sources &#123;</span><br><span class="line">            results += searchType == .name ? source.search(name: text) : source.search(title: text)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="实现适配器模式"><a href="#实现适配器模式" class="headerlink" title="实现适配器模式"></a>实现适配器模式</h2><p>假设要合并另外的员工数据（可能是某个开源或者不开源系统的数据），而另外的系统所定义的员工相关类并不兼容现有结构。如下代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewCoStaffMember</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> role: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, role: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.role = role</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getName</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getRole</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> role</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewCoDirectory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> staff: [<span class="type">String</span>: <span class="type">NewCoStaffMember</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        staff = [<span class="string">"Hans"</span>: <span class="type">NewCoStaffMember</span>(name: <span class="string">"Hans"</span>, role: <span class="string">"Crop Counsel"</span>), <span class="string">"Feek"</span>: <span class="type">NewCoStaffMember</span>(name: <span class="string">"Feek"</span>, role: <span class="string">"VIP"</span>)]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getStaff</span><span class="params">()</span></span> -&gt; [<span class="type">String</span>: <span class="type">NewCoStaffMember</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> staff</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="适配器的Extension实现"><a href="#适配器的Extension实现" class="headerlink" title="适配器的Extension实现"></a>适配器的Extension实现</h2><p><code>Swift</code>实现适配器最优雅的方式是 <code>Swift Extension</code>, <code>Extension</code>为无法修改源码的类增加功能。<br>即<code>接口适配器模式</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NewCoDirectory</span>: <span class="title">EmployDataSource</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> employees: [<span class="type">Employee</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> getStaff().values.<span class="built_in">map</span>(&#123; (servant) -&gt; <span class="type">Employee</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">Employee</span>(name: servant.getName(), title: servant.getRole())</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(name: String)</span></span> -&gt; [<span class="type">Employee</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> createEmployees(<span class="built_in">filter</span>: &#123; (staff) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> staff.getName().range(of: name) != <span class="literal">nil</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(title: String)</span></span> -&gt; [<span class="type">Employee</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> createEmployees(<span class="built_in">filter</span>: &#123; (staff) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> staff.getRole().range(of: title) != <span class="literal">nil</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">createEmployees</span><span class="params">(<span class="built_in">filter</span> filterClosure: <span class="params">(NewCoStaffMember)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; [<span class="type">Employee</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> getStaff().values.<span class="built_in">filter</span>(filterClosure).<span class="built_in">map</span> &#123; (entry) -&gt; <span class="type">Employee</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">Employee</span>(name: entry.getName(), title: entry.getRole())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样，在<code>SearchTool</code>中，可以无缝使用其他已经被适配的结构。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> search = <span class="type">SearchTool</span>(dataSource: <span class="type">SalesDataSource</span>(), <span class="type">DevelopmentDataSource</span>(), <span class="type">NewCoDirectory</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"----list----"</span>)</span><br><span class="line"><span class="keyword">for</span> emp <span class="keyword">in</span> search.employees &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(emp.name) "</span>)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"----search----"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> emp <span class="keyword">in</span> search.search(text: <span class="string">"VIP"</span>, searchType: .title) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"name = \(emp.name) title = \(emp.title)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="适配器的包装类实现"><a href="#适配器的包装类实现" class="headerlink" title="适配器的包装类实现"></a>适配器的包装类实现</h2><p>使用<code>对象适配器模式</code>实现上述功能<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewCoDirectoryAdapter</span>: <span class="title">EmployDataSource</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">let</span> directory = <span class="type">NewCoDirectory</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> employees: [<span class="type">Employee</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> directory.getStaff().values.<span class="built_in">map</span>(&#123; (servant) -&gt; <span class="type">Employee</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">Employee</span>(name: servant.getName(), title: servant.getRole())</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(name: String)</span></span> -&gt; [<span class="type">Employee</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> createEmployees(<span class="built_in">filter</span>: &#123; (staff) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> staff.getName().range(of: name) != <span class="literal">nil</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(title: String)</span></span> -&gt; [<span class="type">Employee</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> createEmployees(<span class="built_in">filter</span>: &#123; (staff) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> staff.getRole().range(of: title) != <span class="literal">nil</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">createEmployees</span><span class="params">(<span class="built_in">filter</span> filterClosure: <span class="params">(NewCoStaffMember)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; [<span class="type">Employee</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> directory.getStaff().values.<span class="built_in">filter</span>(filterClosure).<span class="built_in">map</span> &#123; (entry) -&gt; <span class="type">Employee</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">Employee</span>(name: entry.getName(), title: entry.getRole())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="双向适配器"><a href="#双向适配器" class="headerlink" title="双向适配器"></a>双向适配器</h2><h3 id="Demo-应用及组件信息"><a href="#Demo-应用及组件信息" class="headerlink" title="Demo-应用及组件信息"></a>Demo-应用及组件信息</h3><p><code>DrawingApp</code> 为应用App，其中有绘图draw功能。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ShapeDrawer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">drawShape</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DrawingApp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> drawer: <span class="type">ShapeDrawer</span></span><br><span class="line">    <span class="keyword">var</span> cornerRadius: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(drawer: <span class="type">ShapeDrawer</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.drawer = drawer</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makePicture</span><span class="params">()</span></span> &#123;</span><br><span class="line">        drawer.drawShape()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>SketchComponent</code> 为绘图组件，其中包含一些图形信息。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AppSettings</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> circleShape: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SketchComponent</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">let</span> settings: <span class="type">AppSettings</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(settings: <span class="type">AppSettings</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.settings = settings</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sketchShape</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> settings.circleShape &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Cicle"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Other"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Demo-双向适配器实现"><a href="#Demo-双向适配器实现" class="headerlink" title="Demo-双向适配器实现"></a>Demo-双向适配器实现</h3><font size="4" color="red">应用中需要获取组件上shape信息，组件需要获取app中的cornerRadius信息</font><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoWayAdapter</span>: <span class="title">ShapeDrawer</span>, <span class="title">AppSettings</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> app: <span class="type">DrawingApp</span>?</span><br><span class="line">    <span class="keyword">var</span> component: <span class="type">SketchComponent</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">drawShape</span><span class="params">()</span></span> &#123;</span><br><span class="line">        components?.sketchShape()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> circleShape: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> app = app &#123;</span><br><span class="line">            <span class="keyword">return</span> app.cornerRadius &gt; <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用时：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> twoWayAdapter = <span class="type">TwoWayAdapter</span>()</span><br><span class="line"><span class="keyword">let</span> app = <span class="type">DrawingApp</span>(drawer: twoWayAdapter)</span><br><span class="line"><span class="keyword">let</span> component = <span class="type">SketchComponent</span>(settings: twoWayAdapter)</span><br><span class="line"></span><br><span class="line">twoWayAdapter.app = app</span><br><span class="line">twoWayAdapter.component = component</span><br><span class="line">    </span><br><span class="line">app.makePicture()</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://jingtaotao.top/2018/10/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>iOS有关WebView采坑总结</title>
      <link>http://jingtaotao.top/2018/10/31/WebView%E9%87%87%E5%9D%91%E6%80%BB%E7%BB%93/</link>
      <guid>http://jingtaotao.top/2018/10/31/WebView%E9%87%87%E5%9D%91%E6%80%BB%E7%BB%93/</guid>
      <pubDate>Wed, 31 Oct 2018 02:17:46 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;iOS中关于WKWebView和UIWebView区别及使用方式，网上资料很多，这里不再重复叙述，&lt;a href=&quot;https://developer.apple.com/documentation/webkit/wkwebview&quot; target=&quot;_blank&quot; rel
        
      
      </description>
      
      <content:encoded><![CDATA[<p>iOS中关于WKWebView和UIWebView区别及使用方式，网上资料很多，这里不再重复叙述，<a href="https://developer.apple.com/documentation/webkit/wkwebview" target="_blank" rel="noopener">WKWebview文档</a>，笔者曾对WebView相关做过组件化，有兴趣的可以参考 <a href="https://github.com/jingtao910429/TBInteractiveProtocol" target="_blank" rel="noopener">TBInteractiveProtocol</a>。<br>文档中有很多开发者未曾注意过的细节，例如，WebView方法调用的线程选择：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Important</span><br><span class="line">Call WebKit functions and methods only from your app’s main thread or main dispatch queue.</span><br></pre></td></tr></table></figure><h2 id="WebView加载线程"><a href="#WebView加载线程" class="headerlink" title="WebView加载线程"></a>WebView加载线程</h2><p>如文档所述，WebKit的方法调用只能在主线程，如果不是，会导致白屏或者其他未知错误。例如Html片段如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">    <span class="keyword">self</span>.webView.loadHTMLString(html, baseURL: <span class="type">Bundle</span>.main.bundleURL)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="WebView加载HTML片段"><a href="#WebView加载HTML片段" class="headerlink" title="WebView加载HTML片段"></a>WebView加载HTML片段</h2><h3 id="BaseURL设置"><a href="#BaseURL设置" class="headerlink" title="BaseURL设置"></a>BaseURL设置</h3><p><code>loadHTMLString</code>方法中<code>baseURL</code>的设置一般设置为<code>nil</code>没什么问题，但是会出现 <code>WebView</code> 加载不上的现象，此时设置<code>baseURL</code>是一个好的选择，具体可参考 <a href="https://stackoverflow.com/questions/37013812/wkwebview-wont-loadhtmlstring" target="_blank" rel="noopener">https://stackoverflow.com/questions/37013812/wkwebview-wont-loadhtmlstring</a></p><h3 id="WebView内容高度计算不准确"><a href="#WebView内容高度计算不准确" class="headerlink" title="WebView内容高度计算不准确"></a>WebView内容高度计算不准确</h3><p>高度计算一般使用<code>stringByEvaluatingJavaScript</code>获取。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> height = webView.stringByEvaluatingJavaScript(from: <span class="string">"document.body.scrollHeight"</span>)?.toFloat() &#123;</span><br><span class="line">    <span class="comment">//webview高度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中<code>toFloat()</code>方法的定义：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">toFloat</span><span class="params">()</span></span> -&gt; <span class="type">Float</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> num = <span class="type">NumberFormatter</span>().number(from: <span class="keyword">self</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> num.floatValue</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于<code>scrollHeight</code>、<code>offSetHeight</code>的区别，可参考 <a href="https://www.jianshu.com/p/d267456ebc0d" target="_blank" rel="noopener">图解scrollHeight, clientHeight, offsetHeight, scrollTop以及获取方法</a> 以及其他相关文章。<br>但是会发现，此时的高度并不准确，原因在于html片段，并没有设置<code>meta</code>标签，一般的<code>meta</code>标签设置如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">\</span>"<span class="attr">viewport</span>\" <span class="attr">content</span>=<span class="string">\</span>"<span class="attr">width</span>=<span class="string">device-width</span>",<span class="attr">initial-scale</span>=<span class="string">1,minimum-scale</span>=<span class="string">1,maximum-scale</span>=<span class="string">1,user-scalable</span>=<span class="string">no\</span>" /&gt;</span>"</span><br></pre></td></tr></table></figure></p><p>其中<code>width</code>设置的是<code>device-width</code>，也就是屏幕宽度，但是实际上，WebView的加载并不是完全等于<code>device-width</code>，所以该字段应该根据实际的WebView宽度进行设置。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">formateHtml</span><span class="params">(width: String = <span class="string">"device-width"</span>)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&lt;meta name=\"viewport\" content=\"width="</span> + width + <span class="string">",initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no\" /&gt;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="Cell中WebView的复用"><a href="#Cell中WebView的复用" class="headerlink" title="Cell中WebView的复用"></a>Cell中WebView的复用</h2><h3 id="高度记录"><a href="#高度记录" class="headerlink" title="高度记录"></a>高度记录</h3><p>一般对于WebView的复用问题，首先要记录加载之后的高度，或者是预处理计算高度。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">var</span> valueHeights: [<span class="type">IndexPath</span>: <span class="type">CGFloat</span>] = [:]</span><br></pre></td></tr></table></figure></p><h3 id="反向刷新"><a href="#反向刷新" class="headerlink" title="反向刷新"></a>反向刷新</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//block可自行定义</span></span><br><span class="line">cell?.caculateWebViewHeightBlock = &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (height) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> `<span class="keyword">self</span>` = <span class="keyword">self</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.valueHeights[indexPath] = height</span><br><span class="line">    <span class="comment">//需要记录高度,刷新cell高度</span></span><br><span class="line">    <span class="keyword">self</span>.tableView.reloadData()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><blockquote><p><strong><font color="red" size="3" face="黑体">高度再次传入Cell进行控制，注意如果已知高度，则不需要在loadHtml之后调用block回传高度，否则会死循环！！！！！！</font></strong></p></blockquote><h2 id="如果不存在复用，则可以提前计算加载的高度，然后直接刷新视图。"><a href="#如果不存在复用，则可以提前计算加载的高度，然后直接刷新视图。" class="headerlink" title="如果不存在复用，则可以提前计算加载的高度，然后直接刷新视图。"></a>如果不存在复用，则可以提前计算加载的高度，然后直接刷新视图。</h2><p>笔者的<code>CaculateWebViewManager</code>类可作参考。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> WebKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">CaculateWebViewHeightBlock</span> = ((<span class="number">_</span> height: <span class="type">CGFloat</span>) -&gt; <span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CaculateWebViewManager</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> caculateWebView: <span class="type">WKWebView</span>!</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> heightBlock: <span class="type">CaculateWebViewHeightBlock</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        caculateWebView = <span class="type">WKWebView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, w: kAdaptScreenWidth, h: <span class="number">0</span>))</span><br><span class="line">        caculateWebView.navigationDelegate = <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">caculateHeight</span><span class="params">(width: CGFloat, html: String, heightBlock: CaculateWebViewHeightBlock?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.heightBlock = heightBlock</span><br><span class="line">        </span><br><span class="line">        caculateWebView.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, w: width, h: <span class="number">10</span>)</span><br><span class="line">        caculateWebView.loadHTMLString(html, baseURL: <span class="type">Bundle</span>.main.bundleURL)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">fetchDetailHtml</span>(<span class="title">searchTopicWordsRecord</span>: <span class="title">KnowleadgeDetailContentModel</span>?, <span class="title">width</span>: <span class="title">CGFloat</span>) -&gt; (<span class="title">String</span>, <span class="title">CGFloat</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> tWidth = width - <span class="number">12</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> record = searchTopicWordsRecord &#123;</span><br><span class="line">            <span class="keyword">var</span> html = <span class="string">""</span></span><br><span class="line">            <span class="keyword">let</span> htmlMeta = formateHtml(width: <span class="string">"\(Int(tWidth))px"</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> record.subjectId == <span class="string">"1"</span> &#123;</span><br><span class="line">                html = <span class="string">"\(htmlMeta)&lt;p style=\"font-size:16px;text-align:center;\"&gt;\(record.description)&lt;/p&gt;"</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                html = <span class="string">"\(htmlMeta)\(record.richDescription)"</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (html, tWidth)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">""</span>, tWidth)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">fetchSplitAssociateHtml</span>(<span class="title">type</span>: <span class="title">Int</span>, <span class="title">subjectId</span>: <span class="title">String</span>, <span class="title">splitOrAssociate</span>: <span class="title">String</span>?, <span class="title">width</span>: <span class="title">CGFloat</span>) -&gt; (<span class="title">String</span>, <span class="title">CGFloat</span>) </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> tWidth = width - <span class="number">15</span></span><br><span class="line">        <span class="keyword">let</span> htmlMeta = formateHtml(width: <span class="string">"\(Int(tWidth))px"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> splitOrAssociate != <span class="string">""</span> &amp;&amp; type == <span class="number">0</span> &amp;&amp; subjectId == <span class="string">"1"</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> html = <span class="string">"\(htmlMeta)"</span></span><br><span class="line">            <span class="keyword">let</span> array = splitOrAssociate!.components(separatedBy: <span class="string">"~"</span>)</span><br><span class="line">            <span class="keyword">for</span> (index, item) <span class="keyword">in</span> array.enumerated() &#123;</span><br><span class="line">                <span class="keyword">if</span> index%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">                    html.append(<span class="string">"&amp;nbsp&lt;span style=\"color: red;\"&gt;\(item)&lt;/span&gt;&amp;nbsp"</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    html.append(item)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (html, tWidth)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> splitOrAssociate = splitOrAssociate &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="built_in">split</span> = <span class="string">"\(htmlMeta)\(splitOrAssociate)"</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">split</span>, tWidth)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">""</span>, tWidth)</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CaculateWebViewManager</span>: <span class="title">WKNavigationDelegate</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(<span class="number">_</span> webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(<span class="number">_</span> webView: WKWebView, didFinish navigation: WKNavigation!)</span></span> &#123;</span><br><span class="line">        webView.evaluateJavaScript(<span class="string">"document.body.scrollHeight"</span>, completionHandler: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (result, error) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> `<span class="keyword">self</span>` = <span class="keyword">self</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> webViewHeight = <span class="type">CGFloat</span>(<span class="number">40.0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> height = result &#123;</span><br><span class="line">                webViewHeight = <span class="type">CGFloat</span>(height <span class="keyword">as</span>! <span class="type">Float</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.heightBlock?(webViewHeight)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(<span class="number">_</span> webView: WKWebView, didFail navigation: WKNavigation!, withError error: Error)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>http://jingtaotao.top/2018/10/31/WebView%E9%87%87%E5%9D%91%E6%80%BB%E7%BB%93/#disqus_thread</comments>
    </item>
    
    <item>
      <title>GitHub+Hexo+Next博客搭建实战及优化</title>
      <link>http://jingtaotao.top/2018/10/18/GitHub+Hexo+Next%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%88%98%E5%8F%8A%E4%BC%98%E5%8C%96/</link>
      <guid>http://jingtaotao.top/2018/10/18/GitHub+Hexo+Next%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%88%98%E5%8F%8A%E4%BC%98%E5%8C%96/</guid>
      <pubDate>Thu, 18 Oct 2018 01:46:55 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;我的个人博客链接：&lt;a href=&quot;https://jingtaotao.top&quot;&gt;jingtaotao.top&lt;/a&gt;&lt;br&gt;本文是针对有一定编程基础的Coder，采坑完善后的文章。&lt;/p&gt;
&lt;h2 id=&quot;本文描述概念&quot;&gt;&lt;a href=&quot;#本文描述概念&quot; class=
        
      
      </description>
      
      <content:encoded><![CDATA[<p>我的个人博客链接：<a href="https://jingtaotao.top">jingtaotao.top</a><br>本文是针对有一定编程基础的Coder，采坑完善后的文章。</p><h2 id="本文描述概念"><a href="#本文描述概念" class="headerlink" title="本文描述概念"></a>本文描述概念</h2><p>1、文中 <code>yourname</code> 指的是<code>GitHub</code>账号，比如笔者的 <a href="https://github.com/jingtao910429" target="_blank" rel="noopener">jingtao910429</a>。<br>2、文中 <code>主目录</code> 指的是 <code>Hexo</code> 目录。<br>3、文中 <code>站点配置文件</code> 指的是 <code>主目录</code> 下的 <code>_config.yml</code> 文件。<br>4、文中 <code>主题目录</code> 指的是 <code>themes/next</code> 目录。(<code>Next</code>配置主题时会涉及,如果是<code>yilia</code>主题，则是<code>themes/yilia</code>,其他主题同上)<br>5、文中 <code>主题配置文件</code> 指的是 <code>themes</code> 目录下的 <code>_config.yml</code> 文件。</p><h2 id="博客搭建基础"><a href="#博客搭建基础" class="headerlink" title="博客搭建基础"></a>博客搭建基础</h2><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p><code>windows</code> <a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a> 下载安装。<br><code>Linux</code> 执行命令 <code>sudo apt-get install nodejs</code></p><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p><code>windows</code> <a href="https://github.com/waylau/git-for-win" target="_blank" rel="noopener">https://github.com/waylau/git-for-win</a> 安装。<br><code>Linux</code> 执行命令 <code>sudo apt-get install git</code></p><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>首先列出常用 <code>Hexo</code> 命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate # 启动本地服务器</span><br><span class="line">$ hexo server # 在浏览器输入 http://localhost:4000/就可以看见网页和模板了</span><br><span class="line">$ hexo new &quot;文章名&quot; #新建文章</span><br><span class="line">$ hexo new page &quot;页面名&quot; #新建页面</span><br><span class="line">$ hexo deploy #发布到远端</span><br></pre></td></tr></table></figure></p><p>对应的简写命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure></p><blockquote><p>新建文件夹，安装 <code>Hexo</code>。<br>进入<code>Hexo</code>安装目录，依次执行如下命令：</p><ul><li><code>npm install hexo-cli -g</code></li><li><code>hexo init</code> 初始化网站，此时，安装目录为 <code>Hexo</code> 主目录。<br>也可以使用 <code>hexo init blogCategory</code>, 注意 <code>blogCategory</code>是Hexo安装目录下的二级目录，如果使用二级目录安装 <code>Hexo</code> 那么 <code>Hexo</code> 的主目录就是二级目录。</li><li><code>hexo s</code> 浏览器打开 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 预览网页。<br><br></li></ul></blockquote><h2 id="GitHub配置部署"><a href="#GitHub配置部署" class="headerlink" title="GitHub配置部署"></a>GitHub配置部署</h2><h3 id="GitHub创建Repositories"><a href="#GitHub创建Repositories" class="headerlink" title="GitHub创建Repositories"></a>GitHub创建Repositories</h3><p>创建如图的<code>GitHub.io</code>仓库，注意：<code>yourname.github.io</code>中<code>yourname</code>和Github上对应，如下图：</p><p><img src="https://raw.githubusercontent.com/jingtao910429/Blog-Back-Up/master/photos/hexo-next-githubIo.jpg" alt="创建如图的GitHub.io仓库"></p><p>将主目录下<code>_config.yml</code>中的<code>deploy</code>修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: git@github.com:yourname/yourname.github.io.git  </span><br><span class="line">    #这里的网址填你自己的，这里使用的SSH地址，也可以使用https</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure></p><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p>执行命令 <code>ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot;</code> enter即可。秘钥生成完毕，会得到两个文件<code>id_rsa</code>和<code>id_rsa.pub</code>, <code>vim id_rsa.pub</code>打开文件，copy。进入 <a href="https://github.com/settings/ssh" target="_blank" rel="noopener">https://github.com/settings/ssh</a> </p><p><img src="https://raw.githubusercontent.com/jingtao910429/Blog-Back-Up/master/photos/ssh.jpg" alt="SSH"></p><p>将复制的内容粘贴到Key的输入框，title任意。</p><h3 id="hexo-deploy-出错修正，多数博客未涉及解决方案"><a href="#hexo-deploy-出错修正，多数博客未涉及解决方案" class="headerlink" title="hexo deploy 出错修正，多数博客未涉及解决方案"></a>hexo deploy 出错修正，多数博客未涉及解决方案</h3><blockquote><ul><li><code>deploy not found： git</code><br>解决方案：执行 <code>npm install hexo-deployer-git --save</code> 语句后， 再部署即可。<br>该语句执行后可能会出现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR Local hexo not found</span><br><span class="line">ERROR Try running: &apos;npm install hexo --save&apos;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>导致这个原因为在自己的博客文件夹中,.gitignore文件中添加了node_modules/,导致更新的时候,这个文件夹被忽略，没有被更新上去。</li><li>解决方案:<br>  1、 cmd进入主目录<br>  2、 执行 npm install<br>  3、 执行 hexo server<br>  4、 执行成功后，再到博客下的git中执行 <code>Hexo</code> 命令可以执行成功。</li></ul></blockquote><p><br></p><h2 id="添加主题"><a href="#添加主题" class="headerlink" title="添加主题"></a>添加主题</h2><h3 id="Next主题添加"><a href="#Next主题添加" class="headerlink" title="Next主题添加"></a>Next主题添加</h3><p><code>cd</code> 到主目录下，然后执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p><p>编辑站点配置文件中<code>theme</code>属性，将其由<code>landscape</code>改为<code>next</code>。<br>在主目录执行部署Hexo指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 清理缓存</span><br><span class="line">hexo clean</span><br><span class="line">// 生成文件</span><br><span class="line">hexo generate</span><br><span class="line">// 部署</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p><h3 id="yilia主题添加"><a href="#yilia主题添加" class="headerlink" title="yilia主题添加"></a>yilia主题添加</h3><p>添加<code>yilia</code>主题，可以参考 <a href="https://www.cnblogs.com/jackyroc/p/7681938.html" target="_blank" rel="noopener">我是如何利用Github Pages搭建起我的博客，细数一路的坑</a><br><br></p><h2 id="主题优化"><a href="#主题优化" class="headerlink" title="主题优化"></a>主题优化</h2><p>主题具体优化可参考 <a href="http://wangwlj.com/2017/09/09/blog-opti/" target="_blank" rel="noopener">Hexo搭建的GitHub博客之优化</a><br>其中有几个地方对于Coder来说比较重要的笔者没有涉及到:</p><blockquote><p><strong><em><code>1、标题之间间隔，行间隔</code></em></strong><br><strong><em><code>2、背景圆角</code></em></strong><br><strong><em><code>3、Gemini透明度设置</code></em></strong><br><strong><em><code>4、代码Copy功能</code></em></strong><br><strong><em><code>5、代码折叠</code></em></strong><br><strong><em><code>6、gitalk集成中比较容易出错的地方</code></em></strong></p></blockquote><p>针对以上问题，下面列出解决方案</p><h3 id="标题之间间隔，行间隔"><a href="#标题之间间隔，行间隔" class="headerlink" title="标题之间间隔，行间隔"></a>标题之间间隔，行间隔</h3><p>在<code>Next</code>主题下，是没有对<code>post-body</code>下的<code>p, h1, h2, h3, h4, h5, h6, ul</code>设置相应的样式，所以产生<code>user agent stylesheet</code>浏览器默认样式表,所以打开<code>\themes\next\source\css\_custom\custom.styl</code>下添加代码：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span>, <span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span>, <span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">margin-block-start</span>: <span class="number">0.3em</span>;</span><br><span class="line">  <span class="attribute">margin-block-end</span>: <span class="number">0.3em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打开<code>\themes\next\source\css\_custom\components\post\post-expand.styl</code>修改代码：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post-body</span> &#123;</span><br><span class="line">  +desktop() &#123; text-align: justify; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span> &#123;</span><br><span class="line">    //此处可以控制top和bottom的值，来符合页面要求</span><br><span class="line">    <span class="selector-tag">padding-top</span>: 10<span class="selector-tag">px</span>;</span><br><span class="line">    //padding-bottom: 5px;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.header-anchor</span>&#123;</span><br><span class="line">      <span class="attribute">float</span>: right;</span><br><span class="line">      <span class="attribute">margin-left</span>: <span class="number">10px</span>;</span><br><span class="line">      <span class="attribute">color</span>: $grey-light;</span><br><span class="line">      <span class="attribute">border-bottom-style</span>: none;</span><br><span class="line">      <span class="attribute">visibility</span>: hidden;</span><br><span class="line"></span><br><span class="line">      &amp;:hover&#123;</span><br><span class="line">        <span class="selector-tag">color</span>: <span class="selector-tag">inherit</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;<span class="selector-pseudo">:hover</span> <span class="selector-class">.header-anchor</span>&#123;</span><br><span class="line">      <span class="attribute">visibility</span>: visible;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123; <span class="attribute">list-style</span>: circle; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid $gray-lighter;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="背景圆角"><a href="#背景圆角" class="headerlink" title="背景圆角"></a>背景圆角</h3><p>打开<code>\themes\next\source\css\_variables\Gemini.styl</code>下添加代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$border-radius-inner              = 10px //圆角设置</span><br><span class="line">$border-radius                    = 10px //圆角设置</span><br></pre></td></tr></table></figure></p><h3 id="Gemini透明度设置"><a href="#Gemini透明度设置" class="headerlink" title="Gemini透明度设置"></a>Gemini透明度设置</h3><p>主要是通过修改CSS样式来实现<br><div><div class="fold_hider"><div class="close hider_title">1、文章部分</div></div><div class="fold"><p><code>themes/next/source/css/_schemes/Gemini/index.styl</code><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.post-block</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: $content-desktop-padding;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(255,255,255,0.7);</span><br><span class="line">  <span class="attribute">box-shadow</span>: $box-shadow-inner;</span><br><span class="line">  <span class="attribute">border-radius</span>: $border-radius-inner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div></div><br><div><div class="fold_hider"><div class="close hider_title">2、阅读全文按钮</div></div><div class="fold"><p><code>/themes/next/source/css/_variables/Pisces.styl</code><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$btn-default-radius           = 2px</span><br><span class="line">$btn-default-bg               = rgba(255,255,255,0.5)</span><br><span class="line">$btn-default-color            = $text-color</span><br><span class="line">$btn-default-border-color     = $text-color</span><br><span class="line">$btn-default-hover-color      = white</span><br><span class="line">$btn-default-hover-bg         = $black-deep</span><br></pre></td></tr></table></figure></p></div></div><br><div><div class="fold_hider"><div class="close hider_title">3、分页部分</div></div><div class="fold"><p><code>/themes/next/source/css/_schemes/Gemini/index.styl</code><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.pagination</span> &#123;</span><br><span class="line">  .prev, .next, .page-number &#123;</span><br><span class="line">    <span class="selector-tag">margin-bottom</span>: <span class="selector-tag">initial</span>;</span><br><span class="line">    <span class="selector-tag">top</span>: <span class="selector-tag">initial</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">margin</span>: <span class="selector-tag">sboffset</span> 0 0;</span><br><span class="line">  <span class="selector-tag">background</span>: <span class="selector-tag">rgba</span>(255,255,255,0<span class="selector-class">.7</span>);</span><br><span class="line">  box-shadow: $box-shadow;</span><br><span class="line">  border-radius: $border-radius;</span><br><span class="line">  <span class="selector-tag">padding</span>: 10<span class="selector-tag">px</span> 0 10<span class="selector-tag">px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div></div><br><div><div class="fold_hider"><div class="close hider_title">4、评论区部分</div></div><div class="fold"><p><code>/themes/next/source/css/_schemes/Gemini/index.styl</code><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.comments</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: $content-desktop-padding;</span><br><span class="line">  <span class="attribute">margin</span>: initial;</span><br><span class="line">  <span class="attribute">margin-top</span>: sboffset;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(255,255,255,0.7);</span><br><span class="line">  <span class="attribute">box-shadow</span>: $box-shadow;</span><br><span class="line">  <span class="attribute">border-radius</span>: $border-radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div></div><br><div><div class="fold_hider"><div class="close hider_title">5、侧栏菜单界面</div></div><div class="fold"><p><code>/themes/next/source/css/_schemes/Pisces/_layout.styl</code><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.header-inner</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: $sidebar-desktop;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(255,255,255,0.7);</span><br><span class="line">  <span class="attribute">box-shadow</span>: $box-shadow-inner;</span><br><span class="line">  <span class="attribute">border-radius</span>: $border-radius-inner;</span><br><span class="line"></span><br><span class="line">  +desktop-large() &#123;</span><br><span class="line">    <span class="selector-class">.container</span> &amp; &#123; <span class="attribute">width</span>: $sidebar-desktop; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  +<span class="selector-tag">tablet</span>() &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: auto;</span><br><span class="line">    <span class="attribute">border-radius</span>: initial;</span><br><span class="line">  &#125;</span><br><span class="line">  +<span class="selector-tag">mobile</span>() &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: auto;</span><br><span class="line">    <span class="attribute">border-radius</span>: initial;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div></div><br><div><div class="fold_hider"><div class="close hider_title">6、个人资料界面</div></div><div class="fold"><p><code>/themes/next/source/css/_schemes/Pisces/_sidebar.styl</code><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.sidebar-inner</span> &#123;</span><br><span class="line">//padding: 20px 10px 0;</span><br><span class="line">  <span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span>;</span><br><span class="line">  width: $sidebar-desktop;</span><br><span class="line">  color: $text-color;</span><br><span class="line">  <span class="selector-tag">background</span>: <span class="selector-tag">rgba</span>(255,255,255,0<span class="selector-class">.7</span>);</span><br><span class="line">  box-shadow: $box-shadow;</span><br><span class="line">  border-radius: $border-radius;</span><br><span class="line">  if (hexo-config('motion.enable') and hexo-config('motion.transition.sidebar')) &#123; opacity: 0; &#125;</span><br><span class="line"></span><br><span class="line">  &amp;<span class="selector-class">.affix</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">top</span>: $sidebar-offset;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p></div></div><br>其他<code>Next</code>主题请参考修改。</p><h3 id="代码Copy功能"><a href="#代码Copy功能" class="headerlink" title="代码Copy功能"></a>代码Copy功能</h3><p>参考 <a href="https://www.ofind.cn/blog/HEXO/HEXO%E4%BC%98%E5%8C%96%E4%B9%8B%EF%BC%88%E4%BA%8C%EF%BC%89-%E6%B7%BB%E5%8A%A0%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD.html" target="_blank" rel="noopener">HEXO优化之（二）—-添加复制功能</a></p><p>功能添加出现<code>Clipboard is not defined</code>错误，需要修改一下Clipboard的源码，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Clipboard = fuction()&#123;....&#125;;</span><br><span class="line"><span class="comment">//在Clipboard定义后面增加</span></span><br><span class="line">$.Clipboard = Clipboard;<span class="comment">//这是我增加的代码</span></span><br></pre></td></tr></table></figure></p><p>使用时代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> clipboard = <span class="keyword">new</span> $.Clipboard(<span class="string">'.btn'</span>, &#123;</span><br><span class="line">    text: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//var ue = UM.getEditor('txtContent',&#123;&#125;);</span></span><br><span class="line">        <span class="comment">//ue.queryCommandValue( 'insertcode' );</span></span><br><span class="line">        <span class="keyword">return</span> $(<span class="string">"#"</span>+domId).val();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">clipboard.on(<span class="string">'success'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//console.log(e);</span></span><br><span class="line">    e.clearSelection();</span><br><span class="line">&#125;);</span><br><span class="line">clipboard.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//console.log(e);</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="代码折叠"><a href="#代码折叠" class="headerlink" title="代码折叠"></a>代码折叠</h3><p>主要参考 <a href="https://blog.rmiao.top/hexo-fold-block/" target="_blank" rel="noopener">Hexo Next博客添加折叠块功能添加折叠代码块</a></p><h3 id="Gitalk集成中比较容易出错的地方"><a href="#Gitalk集成中比较容易出错的地方" class="headerlink" title="Gitalk集成中比较容易出错的地方"></a>Gitalk集成中比较容易出错的地方</h3><p>主要参考 <a href="https://asdfv1929.github.io/2018/01/20/gitalk/" target="_blank" rel="noopener">Hexo NexT主题中集成gitalk评论系统</a><br>基本可以顺利集成下来，但是有几个概念笔者并没有阐述清楚：</p><h4 id="Homepage-URL-和-Authorization-callback-URL的设置问题"><a href="#Homepage-URL-和-Authorization-callback-URL的设置问题" class="headerlink" title="Homepage URL 和 Authorization callback URL的设置问题"></a><code>Homepage URL</code> 和 <code>Authorization callback URL</code>的设置问题</h4><p>这两个值对应的是站点地址，也就是对外的访问网址，比如 <code>https://jingtao910429.github.io</code>,如果绑定了域名信息，则是个人域名，比如 <code>https://jingtaotao.top</code></p><h4 id="主目录配置中的repo设置"><a href="#主目录配置中的repo设置" class="headerlink" title="主目录配置中的repo设置"></a>主目录配置中的repo设置</h4><p>repo 对应的是<code>GitHub</code>上的repo地址，比如 <code>jingtao910429.github.io</code></p><p><br></p>]]></content:encoded>
      
      <comments>http://jingtaotao.top/2018/10/18/GitHub+Hexo+Next%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%88%98%E5%8F%8A%E4%BC%98%E5%8C%96/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
